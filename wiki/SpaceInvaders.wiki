#Detalhes da implementação do jogo Space Invaders

= Introdução =

Jogo que buscamos implementar: Space Invaders
Basicamente, o conceito  do jogo se resume a inimigos gerados no topo da tela que descem aos poucos, e o jogador, fixo na base da tela, deve se posicionar de maneira a eliminar os inimigos com seus tiros (trajetória linear) antes que os inimigos consigam tocar a base da tela.
Para mais informações, http://pt.wikipedia.org/wiki/Space_Invaders

Seguimos o conceito inicial, e criamos um jogo no qual você está na base, seus inimigos são gerados aleatoriamente no topo da tela, e a dificuldade aumenta de acordo com sua pontuação atual.

= Detalhes =

O jogo tem basicamente a seguinte estrutura:
===Inicialização das variáveis:===
O programa realiza o "set" de suas variáveis para iniciar uma nova partida, como limpar a tela, desenhar as linhas do fundo da tela, desenhar o personagem no centro da tela, carregar as dificuldades do arquivo de dificuldades, e iniciar o gerador de inimigos.

===Game Loop:===
Dentro do Gameloop, temos um trecho inicial que inicializa inimigos, por meio de verificação de tempo. Essa verificação é exatamente o que dá ao jogo sua dificuldade. A dificuldade na verdade corresponde ao tempo entre geração de inimigos, em milisegundos.
Nossa verificação vê quanto tempo se passou desde que o último inimigo foi gerado. Se o tempo for maior do que a dificuldade, outro inimigo é gerado nessa iteração do gameloop.

Em seguida, após gerar um novo inimigo(inicializa as variáveis do inimigo), entramos no trecho de código que realiza leituras constantes do teclado. Este trecho corresponde a um dos maiores problemas que encontramos na implementação, que só conseguimos aperfeiçoar após muitas tentativas. O grande desafio estava em realizar essa leitura constante das teclas e ter precisão de leitura, ou seja, sempre que uma tecla fosse pressionada, o jogo deveria responder com precisão.
Nossa solução, por fim, foi realizar um Delay de 10 milisegundos logo antes da leitura de teclas, pois assim a precisão da leitura aumenta, e o jogo finalmente ficou limpo quanto a isso. (Antes a leitura era travada, com teclas não sendo reconhecidas, ou sendo reconhecidas mais de uma vez.)

Na leitura de teclas, o personagem nao sofre mudanças em sua posição, e sim variáveis de controle indicam que ele deverá sofrer essas mudanças. As mudanças são então computadas dentro do PROC EscrevePersonagem, na sessão de processamento do código.
A parte mais importante aqui fica no caso de pressionar a barra de espaços. Quando ela é pressionada, um tiro deve ser gerado. Temos então um loop, que busca um tiro que não esteja em uso (em tela) e dá para ele a posição do jogador e inicializa o tiro.

Depois disso, temos o processamento, ainda dentro do gameloop. Esse processamento começa com o update do nosso personagem, seguido da checagem de colisões, que podem modificar variáveis, por isso ela é a segunda parte a ser executada no processamento.
Em seguida, os inimigos são escritos ou apagados, dependendo do resultado da checagem de colisões. Depois disso, temos a mesma situação agora para os tiros. A última coisa é a atualização do placar e da vida.

Lembrando que todos os elementos que são modificados no processamento tem como parâmetros para serem escritos na tela os seus "tempos", que corresponde à ultima vez que o elemento foi atualizado, ou variáveis de existência, indicando se um elemento ainda existe ou não (tiros e inimigos), ou ainda variáveis de estado, indicando se algo deve ou não ser atualizado (personagem e placar/vida, por exemplo).

A ultima coisa do gameloop é a verificação de se o jogo deve terminar, vendo se a vida do personagem chegou a zero. Se chegou, uma variável de fim de jogo é acionada , e a próxima iteração do gameloop terminará o jogo.

===Game Over:===
Quando o jogo termina(vidas = 0), o programa entra na sessão do Game Over, que nada mais é do que uma limpeza geral da tela e informa que o jogo terminou, e indica a pontuação final do jogador nessa sessão.



=Procedures=
Nossas procedures foram as seguintes:

*escreveTiro1*: Recebe em ESI um índice de qual tiro deve ser escrito. Esse tiro será atualizado em X e em Y, e será escrito em tela, ou no caso de uma colisão, o mesmo será deletado.

*EscrevePersonagem*: Baseado nas variáveis de controle do personagem e do teclado, o procedure realiza o update da posição do personagem, e redesenha o personagem na tela.

*escreveInimigo1*: Recebe em ESI o índice de um inimigo. Este inimigo será atualizado caso não exista colisão, e será desenhado em tela. No caso de colisão com um tiro, o inimigo é deletado, e a pontuação é incrementada. No caso de colisão com o chão, o inimigo é deletado e as vidas são decrementadas em 1.

*gerarInimigos*: O procedimento apenas busca o primeiro inimigo disponível(não está em tela) e inicializa ele no topo da tela, com um X aleatório, dentro do espaço indicado pela tela do jogador.

*checaColisões*: Verifica se os tiros atingiram algum inimigo, e indica isso ao jogo por meio das variáveis de controle dos inimigos e dos tiros.

*verificaScore*: Vê se a dificuldade deve ser alterada, observando o score do jogador.

*reinicializaVariaveis*: Apenas reinicia tudo, caso o jogador deseje iniciar outra sessão do jogo, a partir do menu inicial que o professor Menotti escreveu.

==Arquivo complementar:==
Nosso jogo também faz uso de um arquivo complementar "dificuldades.txt", cujo conteúdo corresponde aos valores, em milisegundos, dos intervalos de geração de inimigos. Estes valores são carregados no início do jogo, e são utilizados como parâmetros na geração de inimigos novos.