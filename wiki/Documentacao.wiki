#summary Documentação das funcionalidades implementadas no programa.
#labels Phase-Implementation,Phase-Design

= Introdução =

O objetivo deste projeto é disponibilizar implementações que possam ser usadas para comparar o desempenho das instruções de multimídia nas arquiteturas Intel(r).

O código original do programa pode ser baixado em [http://msdn.microsoft.com/en-us/library/0aws1s9k(v=vs.80).aspx]

----

= Versões 16, 24 e 32 bits =

<wiki:comment>
Grupo 1
Descrever as diferenças de desempenho e em quais implementações se aplicam. (Normal, MMX e SSE)
</wiki:comment>

A análise de desempenho entre as versões de 16, 24 e 32 bits é feita a partir dos códigos-fonte das implementações: Naive, MMX e SSE2.

Primeiramente é importante conhecer a parte teórica referente a cada conjunto de instruções. 

<b>Naive</b>

Trata-se da implementação básica, pois não utiliza um conjunto de instruções específicos para otimização.

<b>MMX</b>

Conjunto de instruções criado pela Intel para aplicações multimídia com a finalidade de aumentar performance. Ele é voltado para a melhora na execução de operações em grandes vetores de dados.
Implementa o modelo de execução SIMD (Single Instruction Multiple Data) pois assim quando se trabalha com arquivos multimídia são utilizados grandes vetores de dados de modo a agilizar a leitura e processamento devido aos registradores de 64 bits.

<b>SSE2</b>

Trata-se do sucessor do MMX e permite aumentar performance em operações de ponto flutuante. Extende as operações do MMX para registradores XMM (64 bits) o que permite ao programador evitar os registradores MM, que não possuem suporte específico para operações de ponto flutuante, fornecendo maior precisão.

===Análise de performance===

Os programas em MMX e SSE2 usam recursos para aumentar a performance das operações e movimentações de informações: utilizam os registradores estendidos de 64 bits para executar várias instruções em um grande vetor de dados em um tempo reduzido, em comparação com os registradores usuais da linguagem. No caso do programa em questão, os registradores são usados para obtenção de vários pixels na tela de uma só vez, e baseado nessas localizações, fazer as operações necessárias em todos estes lugares.

*MMX-16*

O código MMX para cores com 16 bits de profundidade consiste em:

1.Passar o endereço do pixel da posição corrente para uma variável pCur, no formato ULONGLONG(64bits).

2.Por manipulação deste ponteiro, obter as posições dos pixels ao redor (cUp, cDown, cLeft, cRight, cCur) e compará-los a uma máscara previamente inicializada para editar os bits das posições relevantes à cor.

Após isto, as cores dos pixels ao redor são usadas na modificação desejada (no caso, estamos analisando o efeito Blur). A distribuição das cores é feita entre os pixels, e a próxima posição desejada é calculada. A operação é repetida.

*MMX-24*

O código MMX para cores com 24 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato DWORD. 

2.Cria-se uma variável de 64 bits cFader, que será usada nas operações para a modificação dos valores dos pixels. Isto é feito a partir de uma operação chamada UnpackBytesLo de forma simplificada ele pega a dword que pCur aponta e faz um tipo de concatenação com uma dword cheia de zeros da seguinte forma: suponha que pCur aponta pra dword ff0a0b0c. Neste caso, 0a0b0c representa o RGB do pixel e ff sua transparência. Quando se chama cCur.UnpackBytesLo ( *pCur ), ele empacota na variável cCur uma QWORD 00ff000a000b000c, ou seja, ele faz uma "mescla" byte a byte do vetor passado como referência com um vetor de zeros. Então, as operações feitas neste registrador são feitas duas vezes mais (como se fossem feitas em um bit válido e um bit que sempre está em zero). Isto rende uma perda de performance.

3.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes são "desempacotados" e usados nas operações de modificação de cores. Calcula-se o próximo pixel e repete-se o passo 3.

*MMX-32*

O código MMX para cores com 32 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG. 

2.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes(contando com os pixels da diagonal direita superior, diagonal direita inferior e o segundo pixel da direita) são "desempacotados" e usados nas operações de modificação de cores. 

3.Depois das modificações das cores, os pixels são reempacotados em uma variável de 64 bits. Repetem-se os passos 2 e 3.

_Observações sobre MMX:_

Todas as operações em MMX envolvem o uso de instruções de empacotamento de bytes. Estas instruções tem alguns pontos onde a performance do sistema é afetada por operações desnecessárias nos pixels. Por exemplo, o PUNPCKLBW, instrução MMX para o desempacotamento de uma DWORD, gera bits zerados que não contribuem para o programa, e que entram em loops e operações supérfluas.

Podemos ver pela performance dos códigos em MMX que estes não são eficientes neste programa, sendo mais lentos que a implementação Naive e a SSE2.

*SSE2-16*

Este código processa cada pixel em uma WORD, carregando poucos dados em cada uma de suas execuções, fazendo com que sua performance seja diminuída.

1.Passar o endereço da posição corrente para uma variável pCur, no formato __m128i.

2.Por meio de manipulações neste ponteiro, podemos obter as posições dos pixels adjacentes (cDownBase, etc). Estas posições são passadas por uma máscara: cada parte de 16 bits de um pixel tem os últimos cinco bits reservados para as informações de cor (cDown, cUp, etc).

3.Após isto, ele executa as operações matemáticas para no pixel corrente e nos dois próximos pixels à direita. Avança o ponteiro e repetem-se os dois passos.

*SSE2-24*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Com base neste ponteiro corrente, desempacota-o para obter os pixels adjacentes, e executa as operações matemáticas nas cores da posição corrente.

3.Avança o ponteiro, e re-executa o passo 2.

4.O resultado é empacotado na posição do ponteiro corrente. Avança o ponteiro, e recomeça o processo do passo 2.

*SSE2-32*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Fazemos o casting deste ponteiro para o tipo RGBQUAD, que é formado por: três Bytes que fazem referência às cores vermelha, verde e azul, e um Byte reservado. O próximo ponteiro é definido aqui também.

3.Fazemos as operações matemáticas para definir a cor do pixel corrente, e do próximo. O cFader entra logo depois, aumentando ou diminuindo o tom da cor.

4.Empacotamos a cor do pixel corrente no seu ponteiro, e avançamos o pCur. Recomeça o processo a partir do 2.

=== Estudando o desempenho ===

Numa primeira análise observamos as linhas de código (LOC) das implementações MMX e SSE2. Porém sabemos que trata-se apenas de um indicador de performance e não nos dá uma ideia precisa das reais diferenças entre as implementações. As linhas de código do Naive não foram consideradas, pois não apresentam diferença nenhuma.

|| *Versão* || *MMX* || *SSE2* ||
|| *16 bits*|| 538 LOC  || 533 LOC ||
|| *24 bits*|| 204 LOC || 301 LOC || 
|| *32 bits*|| 283 LOC || 311 LOC ||


Já o gráfico a seguir mostra os resultados de testes feitos usando o código fornecido no repositório para os três conjuntos de instruções citados.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,105&chxs=0,676767,11.5,0,lt,676767&chxt=y,x&chbh=a,5,10&chs=600x300&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,100,0,100,0,105&chd=t:87,84,89|42,77,70|66,105,88&chdl=Naive|MMX|SSE2&chtt=Gr%C3%A1fico+de+Desempenho+(FPS)&fake=name.png

|| *Versão* || *Naive* || *MMX* || *SSE2* ||
|| *16 bits* || 87 || 42 || 66 ||
|| *24 bits* || 84 || 77 || 105 ||
|| *32 bits* || 89 || 70 || 88 ||

Obs1: Valores do eixo y em frames per second (fps) e testados em resolução 320x240.

Obs2: Valores possuem certa variância devido ao fato do computador estar executando outras tarefas.

=== Conclusões ===

Após o estudo do funcionamento dos algoritmos e da análise de desempenho de cada um, podemos verificar que a implementação SSE-2 em 24 bits é a que possui melhor desempenho (fps) em relação aos demais.Como o SSE-2 é uma versão avançada do MMX (MMX -> SSE -> SSE-2), não é surpresa tal diferença na performance.

Com relação às implementações restantes, podemos ver que o MMX não foi devidamente implementado, ou seja, poderia ter melhor desempenho se devidamente otimizado.

Por fim, podemos afirmar que a implementação Naive possuí uma performance acima da média, uma vez que a única versão que supera seu desempenho é a SSE-2 de 24 bits.


----

= Implementações =

<wiki:comment>
Grupo 2
Descrever Blur, Blit e Swarm nas três versões (Normal, MMX e SSE).
</wiki:comment>

== Blur/Smooth (Borrar) ==

Este efeito é obtido por meio da média do pixel com seus vizinhos, porém o pixel central tem peso maior, deixando um rastro que ao passar do tempo (dos cálculos da média) vai desaparecendo.
Desta maneira, ao pausar o BLUR, as Llamas do SWARM tendem a acelerar instantaneamente, pois é pausado todos os cálculos de desempacotamento, leitura, e operações matematicas, permitindo com que a capacidade de processamento possa ser utilizada por completa na movimentação das Llamas.

=== _Naive_ ===

Nesta implementação o valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) e dividido por 8 (>> 3).

{{{
void CSurface::BlurBits()
{
    COLORREF cLeft = 0, cCur = PointColor(0,0), cRight, cUp, cDown;
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        cLeft = 0;
        for (int j = 0; j < m_wndWidth; j++) {
            cRight = PointColor(j+1, i);
            cUp = PointColor(j, i-1);
            cDown = PointColor(j, i+1);
            r = (BYTE)(((int)(GetRValue(cCur) << 2) + GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) >> 3);
            g = (BYTE)(((int)(GetGValue(cCur) << 2) + GetGValue(cLeft) + GetGValue(cRight) + GetGValue(cUp) + GetGValue(cDown)) >> 3);
            b = (BYTE)(((int)(GetBValue(cCur) << 2) + GetBValue(cLeft) + GetBValue(cRight) + GetBValue(cUp) + GetBValue(cDown)) >> 3);
            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
            cLeft = cCur;
            cCur = cRight;
        }
    }
}
}}}

=== MMX ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CMMXSurface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);

	CMMX cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CMMX cUp, cDown, cCur, cLeft, cRight;
	CMMX cDest;
	CMMX cMask(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase = *(ULONGLONG*)(pwCur-1);
			cCurBase = pCur[0];
			cRightBase = *(ULONGLONG*)(pwCur+1);
			cUpBase = pCur[-m_qwpl];
			cDownBase = pCur[+m_qwpl];

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			*pCur++ = cDest;
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores MMX sã0 de 64 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar MMX na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight;
	CMMX cLeft;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(DWORD *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(DWORD *)(bpCur+1) );
			*pCur++ = cUp.PackBytes();
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 2 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atrobuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown) .O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight, cRightRight;
	CMMX cDownRight;
	CMMX cLeft;
	CMMX cUpRight;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();
	cCur.UnpackBytesLo( *pCur );

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			cRight.UnpackBytesLo( pCur[1] );
			cRightRight.UnpackBytesLo( pCur[2] );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cUpRight.UnpackBytesLo( pCur[-m_dwpl+1] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );
			cDownRight.UnpackBytesLo( pCur[m_dwpl+1] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cDown = (cDownRight+cUpRight+cCur+cRightRight+(cRight<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
			cDown += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
    	    cDown -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
			cCur = cRightRight;
	
			*(ULONGLONG *)pCur = cUp.PackBytes(cDown);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

=== SSE(n) ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores SSE são de 128 bits, os dados podem ser alinhados, sendo possível manipular 8 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CSSE2Surface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    __m128i *pCur  = (__m128i *)GetPixelAddress(0,0);

	CSSE2 cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CSSE2 cUp, cDown, cCur, cLeft, cRight;
	CSSE2 cDest;
	CSSE2 cMask;
	cMask.Fill(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase.LoadU(pwCur-1);
			cCurBase.Load(pCur);
			cRightBase.LoadU(pwCur+1);
			cUpBase.Load(pCur-m_qqwpl);
			cDownBase.Load(pCur+m_qqwpl);

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			cDest.Store(pCur++);
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores SSE são de 128 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar SSE na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG*)GetPixelAddress(0,0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			pCur++;
			bpCur = (BYTE *)pCur;
			cCur.UnpackBytesLo( pCur[0] );
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
			cCur -= cFader; // increase the fade to white
			cResult -= cFader; // increase the fade to white
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			cResult.PackBytes(pCur-1, cCur);
			pCur++;
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores SSE são 128 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown).O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);
	ASSERT((DWORD_PTR(pCur) & 0xF) == 0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		ASSERT((DWORD_PTR(pCur) & 0xF) == 0);
		do {
			RGBQUAD *pdwCur = (RGBQUAD*)pCur;
			ULONGLONG *pNext = (ULONGLONG*)(pdwCur+1);

			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( *pCur );
			cRight.UnpackBytesLo( *pNext );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cLeft = cRight; 		// Slide left!
			cCur.UnpackBytesLo( pCur[1] );
			cRight.UnpackBytesLo( pNext[1] );
			cUp.UnpackBytesLo( pCur[-m_qwpl+1] );
			cDown.UnpackBytesLo( pCur[m_qwpl+1] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cCur -= cFader; // increase the fade to black
    	    cResult -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
	
			cResult.PackBytes(pCur, cCur);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

== Blit ==

Nesta implementação, as dimensões da janela são verificadas através da função ASSERT (aborta a execução de um programa caso o(s) argumento(s) sejam inválidos). Em seguida, usa uma variável booleana para receber o resultado lógico da função BitBlt (transfere um bloco de bits que corresponde à core de um retângulo de pixels de um ponto da tela para outro) que também é verificada com a função ASSERT.
Desta maneira, ao pausar o BLIT, a imagem parece estar pausada, e ao despausar, uma nova disposição é mostrada. Isso acontece pois os valores de cada ponto continuam sendo calculados e modificados, entretanto, sem serem transferidos para a tela.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,80&chxt=y,x&chbh=a&chs=300x225&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,80,0,80,0,80&chd=t:47,48,49|19,40,32|30,56,44&chdl=Na%C3%AFve|MMX|SSE(2)&chtt=Desempenho+com+a+fun%C3%A7%C3%A3o+BLITT+desativada&fake=name.png

{{{
void CSurface::BlitBits()
{
	ASSERT(m_wndHeight && m_wndWidth);
    BOOL bStat = m_image.BitBlt(m_hDestDC, 0, 0, m_wndWidth, m_wndHeight, 0, m_kDeltaY);

    ASSERT(bStat);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC, // identificador
	_In_ int xDest, // coordenada X do bloco destino
	_In_ int yDest, // coordenada Y do bloco destino
	_In_ int nDestWidth, // largura dos blocos
	_In_ int nDestHeight, // altura dos blocos
	_In_ int xSrc, // coordenada X do bloco fonte
	_In_ int ySrc, // coordenada Y do bloco fonte
	_In_ DWORD dwROP) const throw() // código da operação que define como os blocos fonte e destino são combinados
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, xSrc, ySrc, dwROP );

	ReleaseDC();

	return bResult;
}
}}}

== Swarm ==

=== _Naive_ ===

Nesta implementação, foi definida a classe Swarm e suas funções de manipulação. O construtor (CSwarm::CSwarm()) cria um ponteiro para a imagem de fundo (*CSurface) que inicia com NULL. O destrutor (CSwarm::~CSwarm()) chama a função de destruição (CSwarm::Destroy()) que deleta todos os líderes, todas as lhamas, zera seus contadores e atribue NUL à imagem de fundo. A função de inicialização (CSwarm::Initialize) começa destruindo a imagem atual, verificando as dimensões da nova imagem, limita as bordas da imagem e cria líderes (classe de pontos que se movimentam randomicamente pela imagem deixando rastros brancos) e lhamas (classe de pontos que seguem os líderes e deixam rastros coloridos e trocam de cor quando atingem uma borda da imagem ou quando obtém um novo líder). A função GetLeader(*CSwarm::GetLeader()) retorna o líder a ser seguido pelas lhamas. A função (CSwarm::Tick()) faz um sorteio onde cria um novo líder a partir de outro e deleta o antigo, e em seguida aplica essa funçao para todos outros líderes e lhamas.
Desta maneira, ao pausar o SWARM, o líder e suas lhamas param de se movimentar, fazendo com que os rastros parem de ser criados e desapareçam aos poucos, devido ao efeito do BLUR.

=== MMX ===

-

== Fade In/Out (Transição) ==

<wiki:comment>
Grupo 3
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Esta funcionalidade faz a transição de uma imagem a outra e está implementada apenas com instruções de ponto flutuante (_Naive_).

=== _Naive_ ===

Nesta implementação o valor de `alpha` varia entre 0.0 e 1.0 gradualmente fazendo com que a imagem de origem `cO` se transforme na imagem de destino `cD`.

{{{
            r = (BYTE)((GetRValue(cO)*alpha+GetRValue(cD)*(1.0-alpha)));
            g = (BYTE)((GetGValue(cO)*alpha+GetGValue(cD)*(1.0-alpha)));
            b = (BYTE)((GetBValue(cO)*alpha+GetBValue(cD)*(1.0-alpha)));
}}}

=== MMX ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CMMXUnsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

=== SSE(n) ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CSSE2Unsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

== Grayscale (Tons de cinza) ==

<wiki:comment>
Grupo 4
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Este filtro transforma a imagem atual em uma imagem com tons de cinza.

=== _Naive_ ===

Para esta implementação os valores R, G, B são atualizados com uma média simples entre estes valores.

{{{
void CSurface::GrayScale()
{
	COLORREF cCur;		//declara um dword
	BYTE r, g, b;		//variáveis tipo byte que receberão os valores RGB

	//realiza um loop dentro do outro para percorrer a tela inteira
	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);		//pega um pixel da tela da posição [i,j]
			r = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);	//realiza média entre valores RGB e atualiza valor R
			g = r;	//atualiza valor de G com média ja calculada em R
			b = r;	//atualiza valor de B com média ja calculada em R
			PointColor(j,i,RGB(b,g,r));		//reescreve na tela o pixel do valores RGB modificados na posição [i,j]
		}
	}
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 10 fps. 

=== MMX ===

Esta implementação utilizou inline assembly para acessar os registradores de 64 bits mmx. A ideia do código é simples: através de uma máscara que seleciona um byte por vez, os valores RGB são extraídos e uma média simples é realizada entre eles. Com isso o valor do pixel atual é modificado utilizando a média calculada anteriormente.  
 
{{{
void CMMXSurface32Intrinsic::GrayScale()
{
    int height = GetVisibleHeight()*2;	//altura multiplicada por 2 pois são pixels de 32 bits em variáveis de64 bits (2x maior)
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xFF;	//seleciona um byte de alguma variável (utilizada para pegar valores individuais de RGB)	
	ULONGLONG pixel;	//recebe os valores referentes a um ponto da tela
	ULONGLONG next;		//recebe os valores do próximo ponto a partir de pixel 
	
	pixel = *(ULONGLONG *)pCur;	//faz um casting 64 bits dos dados do ponto atual na variável pixel
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next = *(ULONGLONG *)(pCur+1);	//próximo ponto recebe o ponteiro que aponta para um ponto na tela + 1
			
			//utilização dos registradores mmx 64 bits com inline assembly 
			__asm{
				movq mm0, pixel		//registrador mm0 reebe o valor do pixel atual
				pand mm0, mascara	//valor de mm0 recebe uma mascara para selecionar seu 1 byte menos significativo (B)
				movq mm1, mm0		//guarda o valor calculado acima em mm1
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 8		//realiza um shift lógico para a direita para pegar o próximo byte
				pand mm0, mascara	//utilizar mascara para isolar um byte (G)
				paddd mm1, mm0		//soma o valor calculado anteriormente em mm1 (B+G)
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 16		//realiza um shift lógico para direita para pegar o 3 byte
				pand mm0, mascara	//utiliza mascara para isolar um byte (R)
				paddd mm1,mm0		//soma o valor calculado acima em mm1 (B+G+R)
				movq pixel, mm1		//move para a variável pixel a soma dos valores RGB calculados nos registradores mmx
			}

			pixel /= 3;				//realiza media dos valores RGB ((R+G+B)/3)

			__asm{
				movq mm0, pixel		//mm0 recebe a media dos valores RGB
				movq mm1, mm0		//copia mm0 em mm1
				psllq mm0, 8		//realiza um shift lógico para esquerda em 1 byte
				paddd mm1, mm0		//soma a (media<<8) em mm1 
				psllq mm0, 8		//novamente um shift para esquerda em 1 byte
				paddd mm1, mm0		//soma a (media<<16) em mm1
				movq pixel, mm1		//mm1 agora possui os valores médios RGB (GrayScale), então salva isso em pixel
			}

			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);
	} while (--height > 0);
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 19 fps, o que mostra um bom ganho de desempenho comparando com a versão Naive, que consegue fazer somente 10 fps.

=== SSE(n) ===

Esta implementação utilizou inline assembly para acessar os registradores de 128 bits sse. A lógica do código é a mesma da implementação MMX, a diferença é que agora dois pixels são processados de uma vez só em cada passagem do loop, gerando ganho de desempenho.

{{{
void CSSE2Surface32Intrinsic::GrayScale()
{
    int height = GetVisibleHeight()*2;				//aumenta a altura em 2 pois são processados 2 pixels de 32-bits de uma só vez em variáveis de 128 bits	
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	//ponteiro para posição atual da tela
	
	ULONGLONG mascara = 0xFF;						//máscara para selecionar um byte por vez
	ULONGLONG pixel1, pixel2;						//variaveis de 64 bits que receberão valores de dois pixels consecutivos
	ULONGLONG next1, next2;							//variéveis que guardam a próximas posições de pixel1 e pixel2
	ULONGLONG media1, media2;						//medias RGB de pixel1 e pixel2 respectivamente

	pixel1 = *(ULONGLONG *) pCur;					//pixel1 recebe pixel que está sendo apontado no inicio (0,0) 
	pixel2 = *(ULONGLONG *) (pCur+1);				//pixel2 recebe pixel consecutivo (0,1)
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next1 = *(ULONGLONG *) (pCur+2);		//guarda próximo valor para pixel1	
			next2 = *(ULONGLONG *) (pCur+3);		//guarda próximo valor para pixel2	
			
			__asm{
				movq xmm0, pixel1					//move pixel1 para os 64 bits menos significativos de xmm0 (128 bits)
				movhpd xmm0, pixel2					//move pixel2 para os 64 bits mais significativos de xmm0
				movq xmm1, mascara					//xmm1 fará o papel de seletor de bytes especificos de xmm0
				pand xmm1,xmm0						//seleciona primeiro byte de xmm0 e guarda em xmm1
				movq xmm2,xmm1						//xmm2 receberá a soma dos bytes selecionados
				movq xmm1,mascara					
				psrldq xmm0,1						//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media1,xmm2					//recebe a soma dos valores RGB de pixel1 (parte menos significativa de xmm0)
				movq xmm1,mascara
				psrldq xmm0,2						//desloca em 2 para direita xmm0, para selecionar agora sua metade mais significativa (pixel2)
				pand xmm1,xmm0
				movq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media2,xmm2					//salva a soma dos valores RGB de pixel2 em media2
			}

			media1 /= 3;							//realiza média efetiva dos pixels
			media2 /= 3;

			__asm{
				movq xmm0,media1					//xmm0 receberá as medias byte a byte 
				movq xmm1,xmm0
				pslldq xmm0,1
				paddq xmm0,xmm1
				pslldq xmm0,1
				paddq xmm0,xmm1
				movq pixel1,xmm0					//atualiza o valor de pixel1, com xmm0 que contém a média nos seus valores RGB 
				movq xmm0,media2
				movq xmm1,xmm0
				pslldq xmm0,1
				paddq xmm0,xmm1
				pslldq xmm0,1
				paddq xmm0,xmm1
				movq pixel2,xmm0					//atualiza o valor de pixel2, com xmm0 que contém a média nos seus valores RGB
			}

			*(ULONGLONG *)pCur = pixel1;			//joga o valor calculado de pixel1 de volta na tela
			*(ULONGLONG *)(pCur+1) = pixel2;		//joga o valor calculado de pixel2 de volta na tela
			pixel1 = next1;							//pixel1 recebe o próximo pixel 
			pixel2 = next2;							//pixel2 recebe o próximo pixel
			pCur += 2;								//aumenta o ponteiro da tela em 2 (calcula 2 pixels por vez)
		} while (--width > 0);
	} while (--height > 0);
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 23 fps, demonstrando que o processamento de 2 pixels por vez consegue ainda ganhar no desempenho em relação a implementação MMX e mais que dobrar a quantidade de fps calculados em relação a versão Naive.



== Sobel (Detecção de bordas) ==

<wiki:comment>
Grupo 5
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

O mecanismo de detecção de borda Sobel é elaborado com a finaliadde de encontrar os pixels onde há uma mudança no nível de intensidade, sendo está mudança uma característica relevante de uma borda em uma imagem. Assim quando esses pixel estão próximos podem ser destacados formando uma borda.
A sua implementação consiste no cálculo do gradiente da imagem. Esse cálculo é feito definindo máscaras que caracterizam a variação de intensidade presente nas bordas de imagens, e em seguida fazer a convolução da imagem pela máscara.

=== _Naive_ ===

{{{

//Máscara do sobel
//X
GXS[0][0] = -1; GXS[0][1] = 0; GXS[0][2] = 1;
GXS[1][0] = -2; GXS[1][1] = 0; GXS[1][2] = 2;
GXS[2][0] = -1; GXS[2][1] = 0; GXS[2][2] = 1;
//Y
GYS[0][0] = -1; GYS[0][1] = -2; GYS[0][2] = -1;
GYS[1][0] = 0; GYS[1][1] = 0; GYS[1][2] = 0;
GYS[2][0] = 1; GYS[2][1] = 2; GYS[2][2] = 1;

void CSurface::Sobel()
{
    COLORREF cCur;

    sumX = 0;
    sumY = 0;
    SUM = 0;

    //Percorre toda imagem
    for (y = 0; y < m_wndHeight; y++) {
        for (x = 0; x <m_wndWidth; x++) {
	    sumX = 0;
	    sumY = 0;

	    //Se for boada, atribui o valor 0(preto)
	    if((y==0) || (y == (m_wndHeight - 1)) || (x==0) || (x == (m_wndWidth - 1)))
	        SUM = 0;
		else{
		    for(I=-1; I<=1; I++){
		        for(J=-1; J<=1; J++){
		            piX = J + x;
			    piY = I + y;

			    //Pega o valor da imagem corrente
			    cCur = PointColor(piX,piY);

			    r = GetRValue(cCur);
			    g = GetGValue(cCur);
			    b = GetBValue(cCur);

			    NC = (r+g+b)/3;

			    sumX = sumX + (NC) * GXS[J+1][I+1];
			    sumY = sumY + (NC) * GYS[J+1][I+1];
			}
		    }

		    SUM = abs(sumX) + abs(sumY);
		}

		if(SUM>255) SUM=255;
		if(SUM<0) SUM=0;
		newPixel = ((unsigned char)(SUM));
			
		PointColorT(x,y,RGB(newPixel,newPixel,newPixel));
	    }
	}

    //Quando terminar, copia o resultado para a imagem corrente
    Copy(t_image);
}
}}}

== Posterize Filter ==

<wiki:comment>
Grupo 9
Implementar e descrever algum filtro do site http://www.jhlabs.com/ip/filters/as nas versões Normal, MMX e SSE.
</wiki:comment>


O filtro Posterize reduz a quantidade de possiveis váriações das cores na imagem, fazendo com que uma imagem digital que contém uma variação de 0 a 16777215(FFFFFF em hexadecimal) de cores, passaria a ter uma variação de 0 a 256, ou até de 0 a 64 de cores. Esse efeito pode ser uma alternativa quando não se tem uma grande paleta de cores pra se descrever uma imagem. Um exemplo de quando não se pode descrever uma imagem com várias cores é essa imagem  feita de Martin Luther King Jr. com milhares de cubos mágicos:

(Imagens tiradas:  http://infutilidades.wordpress.com/2011/11/09/martin-luther-king-e-milhares-de-cubos-magicos/ )
 
http://infutilidades.files.wordpress.com/2011/11/dream_big_01.jpg?w=590
Fig 1 : Imagem feita a partir de vários cubos mágicos.

http://infutilidades.files.wordpress.com/2011/11/dream_big_02.jpg?w=590 
Fig 2: Encaixando os cubos para a confecção da imagem.

A implementação deste filtro foi feita de forma simples. Ele foi implementado por meio de mascara de bit. A mascara de bit informa quais os bits que serão interpretados na variável,  pois sera feita a operação AND e dessa forma só será interpretado os bits que na mascara estiverem setados como 1. 

Armazena o valor de cada cor em uma variável diferente. ( r <- redvalue; b <- bluevalue; g <- greenvalue)

Armazena o valor da mascara que se deseja aplicar. Esse valor não pode conter 0 entre 1’s, pois assim gerará um buraco entre as cores, assim como nº 2 do exemplo a seguir. 
Ex aplicando a operação AND: 
||ex1||ex2||ex3||ex4||ex5||ex6||
||001||010||011||100||101||111||
||101||101||101||101||101||101||
||001||000||001||100||101||101||

Agora basta aplicar a mascara para cada cor, armazenar os valores nas variáveis de suas devidas cores e mandar exibir o novo pixel.
Com a aplicação do posterize na tela inicial do programa, que está em movimento, podemos ver a sua influência no processamento da imagem. Ficou assim:
||Tipo||Sem Efeito||Com Efeito||
||NAIVE||74 fps||49 fps||
||MMX||65 fps||63 fps||
||SSE2||87 fps||84 fps||

Ps: Os testes foram feitos nas versões de 32 bits.

Na implementação mostrada a seguir a mascara adotada para cada cor foi C0 hexa ou 11000000 em bits. Sendo assim, considerando somente as cores(Vermelho, Verde e Azul), teremos 64 cores diferentes disponíveis para descrever a imagem.


== _Naive_ ==
{{{
void CSurface::Posterize()
{
	if (!inicializado) {
		inicializar();
		inicializado = true;
	}
	COLORREF cCur = PointColor(0,0);
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);
			r = (BYTE)( (int)GetRValue(cCur) & 0xC0 );
			g = (BYTE)( (int)GetGValue(cCur) & 0xC0 );
			b = (BYTE)( (int)GetBValue(cCur) & 0xC0 );

            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
        }
    }
}
}}}

=== MMX ===
{{{
void CMMXSurface32Intrinsic::Posterize()
{
	int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xC0C0C0C0C0C0C0C0;		//0xC = 1100, preservar dois MSD de cada byte.
	ULONGLONG pixel;

	/* Iteracao principal, processa 2 pixeis em cada iteracao */
	do {
		int width = m_width;
		do {
			pixel = *(ULONGLONG *)pCur;
			// inline assembly
			__asm{
				movq mm0, pixel;	// ler pixeis atuais para registrador
				pand mm0, mascara	// aplicar mascara para descardar bits menos significativos
				movq pixel, mm0;
			}
			*(ULONGLONG *)pCur = pixel;
			pCur+= 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

=== SSE(n) ===
{{{
void CSSE2Surface32Intrinsic::Posterize()
{
	int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD *) GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0x00C0C0C000C0C0C0;		//0xC = 1100, preservar dois MSD de cada byte.
	ULONGLONG pixel1, pixel2;

	/* Iteracao principal, processa 2 pixels em cada iteracao */
	do {
		int width = m_width;
		do {
			pixel1 = *(ULONGLONG *)pCur;
			pixel2 = *(ULONGLONG *)(pCur+2);
			// inline assembly
			__asm{
				movq xmm0, pixel1	// ler pixels atuais para registrador
				movhpd xmm0, pixel2
				movq xmm1, mascara
				movhpd xmm1, mascara

				pand xmm0, xmm1	// aplicar mascara para descartar bits menos significativos

				movhpd pixel2, xmm0
				movq pixel1, xmm0
			}
			*(ULONGLONG *)pCur = pixel1;
			*(ULONGLONG *)(pCur+2) = pixel2;
			pCur+= 4;
		} while (--width > 0);
	} while (--height > 0);
}
}}}


Posterize Filter


=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Mandelbrot ==

<wiki:comment>
Grupo 6
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

----

= Capture =

----

= GPU (OpenCL) =

<wiki:comment>
Grupo 7
Implementar e descrever a função InvertImage nas versões Normal, MMX e SSE
</wiki:comment>

----

= Threshold filter =

<wiki:comment>
Threshold Filter Grupoe 13
</wiki:comment>

O filtro de threshold converte uma imagem A, multispectral, primeiramente para uma imagem no padrão em cinza I, mediante a média aritmética das cores no formato RGB,  para uma imagem binária A'. A imagem de saida A' substitui todos os pixels p(i,j) da imagem intermediaria I com valor maior que um limiar L predefinido, para o valor/classe 1(255 em decimal e FF em hexadecial) e substitui os pixels com valor menor ou igual para o valor/classe 0.

http://www.aforgenet.com/framework/docs/html/img/imaging/grayscale.jpg

Fig 1 : Imagem Inicial

http://www.aforgenet.com/framework/docs/html/img/imaging/threshold.jpg

Fig 2 : Imagem Resultante

== _Naive_ ==

A variável limiar está definida como 120, outros valores no intervalo de 0 a 255 produzem imagens de saída diferentes devido ao fato da classificação para 0 ou 1 depender desta escolha. Em algumas imagens tal classificação binária é inapropriada pois mais de uma classe de objetos podem possuir valores de limiares distintos, desta forma a limiarização com limiar fixo pode erodir consideravelmente a imagem de saída causand. Neste implementaçao apenas duas classes são suficientes, pois o único objeto de interesse para segmentação são as linhas desenhadas e o background.

Abaixo conversão para imagem em escala de cinza I e classificação dos pixels de acordo com o limar para preto(0) ou branco(255).

{{{
void CSurface::Threshold()
{
	COLORREF cCur;	//declara um dword
	BYTE r, g, b, limiar, media;
	limiar = 120;
	//percorre a tela em cada ponto
	for (int l = 0; l < m_wndHeight; l++) {
		for (int m = 0; m < m_wndWidth; m++) {
			cCur = PointColor(m,l);
			media = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3); //calcula a media do rgb do pixel corrente
			if (media > limiar) {
				r = 255;	
				g = 255;	
				b = 255;	
			}else{
				r = 0;	
				g = 0;	
				b = 0;
			}
			PointColor(m,l,RGB(b,g,r)); //reatribui o valor alterado no ponto
		}
	}
}

}}}

== _MMX_ ==

Abaixo conversão para imagem em escala de cinza I e classificaáo dos pixels de acordo com o limar para preto(0x000000) ou branco(0xFFFFFF). 

{{{
void CMMXSurface32Intrinsic::Threshold()
{
	int height = GetVisibleHeight()*2;	//altura multiplicada por 2 pois são pixels de 32 bits em variáveis de64 bits (2x maior)
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xFF;	//seleciona um byte de alguma variável (utilizada para pegar valores individuais de RGB)	
	ULONGLONG pixel;	//recebe os valores referentes a um ponto da tela
	ULONGLONG next;		//recebe os valores do próximo ponto a partir de pixel 
	ULONGLONG limiar = 120; //define um limiar para inversao do pixel

	pixel = *(ULONGLONG *)pCur;	//faz um casting 64 bits dos dados do ponto atual na variável pixel
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next = *(ULONGLONG *)(pCur+1);	//próximo ponto recebe o ponteiro que aponta para um ponto na tela + 1
			
			//utilização dos registradores mmx 64 bits com inline assembly 
			
			__asm{
				movq mm0, pixel		//registrador mm0 reebe o valor do pixel atual
				pand mm0, mascara	//valor de mm0 recebe uma mascara para selecionar seu 1 byte menos significativo (B)
				movq mm1, mm0		//guarda o valor calculado acima em mm1
				
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 8		//realiza um shift lógico para a direita para pegar o próximo byte
				pand mm0, mascara	//utilizar mascara para isolar um byte (G)
				paddd mm1, mm0		//soma o valor calculado anteriormente em mm1 (B+G)
				
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 16		//realiza um shift lógico para direita para pegar o 3 byte
				pand mm0, mascara	//utiliza mascara para isolar um byte (R)
				paddd mm1,mm0		//soma o valor calculado acima em mm1 (B+G+R)
				
				movq pixel, mm1		//move para a variável pixel a soma dos valores RGB calculados nos registradores mmx
			}

			pixel /= 3;				//realiza media dos valores RGB ((R+G+B)/3)
			if (pixel>limiar){		//define qual a atribuicao do pixel a partir do limiar
				pixel = 0xFFFFFF;
			}else{
				pixel = 0x000000;
			}

			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);
	} while (--height > 0);
}

}}}

== _SSE_ ==

Nesta implementação pixel1 e pixel2 são executados na mesma iteração, assim como media1 e media2 para comparação com o limiar.

{{{

void CSSE2Surface32Intrinsic::Threshold(){
	int height = GetVisibleHeight()*2;				//aumenta a altura em 2 pois são processados 2 pixels de 32-bits de uma só vez em variáveis de 128 bits	
	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	//ponteiro para posição atual da tela
	
	ULONGLONG mascara = 0xFF;						//máscara para selecionar um byte por vez
	ULONGLONG pixel1, pixel2;						//variaveis de 64 bits que receberão valores de dois pixels consecutivos
	ULONGLONG next1, next2;							//variéveis que guardam a próximas posições de pixel1 e pixel2
	ULONGLONG media1, media2;						//medias RGB de pixel1 e pixel2 respectivamente

	ULONGLONG limiar = 120;

	pixel1 = *(ULONGLONG *) pCur;					//pixel1 recebe pixel que está sendo apontado no inicio (0,0) 
	pixel2 = *(ULONGLONG *) (pCur+1);				//pixel2 recebe pixel consecutivo (0,1)
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next1 = *(ULONGLONG *) (pCur+2);		//guarda próximo valor para pixel1	
			next2 = *(ULONGLONG *) (pCur+3);		//guarda próximo valor para pixel2	
			
			__asm{
				movq xmm0, pixel1					//move pixel1 para os 64 bits menos significativos de xmm0 (128 bits)
				movhpd xmm0, pixel2					//move pixel2 para os 64 bits mais significativos de xmm0
				movq xmm1, mascara					//xmm1 fará o papel de seletor de bytes especificos de xmm0
				pand xmm1,xmm0						//seleciona primeiro byte de xmm0 e guarda em xmm1
				movq xmm2,xmm1						//xmm2 receberá a soma dos bytes selecionados
				movq xmm1,mascara					
				psrldq xmm0,1						//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media1,xmm2					//recebe a soma dos valores RGB de pixel1 (parte menos significativa de xmm0)
				movq xmm1,mascara
				psrldq xmm0,2						//desloca em 2 para direita xmm0, para selecionar agora sua metade mais significativa (pixel2)
				pand xmm1,xmm0
				movq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media2,xmm2					//salva a soma dos valores RGB de pixel2 em media2
			}

			media1 /= 3;							//realiza média efetiva dos pixels
			media2 /= 3;

			if (media1>limiar){
				pixel1 = 0xFFFFFF;
			}else{
				pixel1 = 0x000000;
			}

			if (media2>limiar){
				pixel2 = 0xFFFFFF;
			}else{
				pixel2 = 0x000000;
			}

			*(ULONGLONG *)pCur = pixel1;			//joga o valor calculado de pixel1 de volta na tela
			*(ULONGLONG *)(pCur+1) = pixel2;		//joga o valor calculado de pixel2 de volta na tela
			pixel1 = next1;							//pixel1 recebe o próximo pixel 
			pixel2 = next2;							//pixel2 recebe o próximo pixel
			pCur += 2;								//aumenta o ponteiro da tela em 2 (calcula 2 pixels por vez)
		} while (--width > 0);
	} while (--height > 0);
}

}}}

Para avaliação do  desempenho, foram consideradas uma imagem de 320x240 pixel. O desempenho melhor foi nas implementações de 32 bits para Naive, SSE e MMX.
Com a aplicação do threshold filter na tela inicial do programa, podemos ver a influência no processamento da imagem da seguinte forma:
||Tipo||Original||Threshold||
||NAIVE||30 fps||20 fps||
||MMX||18 fps||17 fps||
||SSE2||34 fps||32 fps||

Portanto, através de análises dos dados anteriores, podemos notar uma grande vantagem ao utilizar o SSE pra 32 bits percorrendo de 2 em 2 pixel que foi de 32 fps e não somente em 1 pixel conforme MMX e Naive, que foram de aproximadamente 18 fps.

----

= Mask filter =

<wiki:comment>
Mask Filter Grupo 15
</wiki:comment>

O Mask Filter consiste basicamente na aplicação de uma máscara de 32-bits para cada pixel, podendo ser utilizado para filtrar uma porcentagem ou totalidade de 1 ou mais cores.

Em nossa aplicação, decidimos por fazer com que o filtro retirasse por completo a cor Vermelha.

Para isso, é criada uma máscara de bit que realiza a operação AND em cada pixel, resultando nas novas cores buscadas.

Seguinte estão os códigos, todos nas versões 32 bits.

== _Naive_ ==

Executa a operação AND com máscara de 1 em 1 pixel no loop criado.
{{{

void CSurface::Mask()
{
	//COLORREF mascara = RGB(0,256,256);
	DWORD mascara = 0xff00ffff;

	//COLORREF guarda a cor em RGB como 0x00bbggrr
	COLORREF cor;


	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cor = PointColor(j,i) & mascara;

			//Deixa na forma 0x00rrggbb para usar o PointColor
			cor = (cor & 0xff) << 16 | ((cor >> 8) & 0xff) << 8 | (cor >> 16) & 0xff;

			PointColor(j,i,cor);
		}
	}
}

}}}

== _MMX_ ==
Nesse caso, o registrador de 64 bits tem capacidade para receber 2 pixels, e portanto aplica-se a máscara em ambos de cada vez.

{{{

void CMMXSurface32Intrinsic::Mask()
{
	ULONGLONG mascara = 0xFF00FFFFFF00FFFF; // Remove componente vermelha = 00ggbb

    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);
	ULONGLONG pixels;

	int height = GetVisibleHeight();
	while (height--)
	{
		int width = m_width;	//m_width = (width+1)/2; pois editamos 2 pixels por iteracao
		while(width--)
		{
			pixels = *(ULONGLONG *)pCur;
			
			__asm
			{
				movq mm0, pixels	// registrador mm0 recebe 2 pixels
				pand mm0, mascara	// aplica mascara
				movq pixels, mm0
			}

			*(ULONGLONG *)pCur = pixels;    // Imprime dois pixels na tela

			pCur += 2;
		}
	}
}

}}}

== _SSE3_ ==
O registrador xmm0 recebe 4 pixels e a máscara é novamente aplicada, jogando quatro pixels na tela após a operação AND

{{{


void CSSE2Surface32Intrinsic::Mask()
{
	ULONGLONG mascara = 0xFF00FFFFFF00FFFF; // Remove componente vermelha = 00ggbb

	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);
	ULONGLONG pixels12, pixels34;


	int height = GetVisibleHeight();
	while (height--)
	{
		int width = m_width;
		while(width--)
		{
			pixels12 = *(ULONGLONG *)pCur;
			pixels34 = *(ULONGLONG *)(pCur+2);
			
			__asm
			{
				movq xmm0, pixels12	// xmm0 recebe 2 pixels em sua metade inferior
				movhpd xmm0, pixels34    // xmm0 recebe 2 pixels em sua metade inferior
// xmm1 recebe a mascara a ser aplicada em 4 pixels simultaneamente
// Essa instrucao e do SSE3, se nao puder usar, descomentar linhas abaixo

				movq  xmm1, mascara
				movhpd xmm1, mascara

				pand xmm0, xmm1	// aplica mascara

				movq pixels12, xmm0
				movhpd pixels34, xmm0
			}

			// Imprime quatro pixels na tela
			*(ULONGLONG *)pCur = pixels12;
			*(ULONGLONG *)(pCur+2) = pixels34;

			pCur += 4;
		}
	}
}

}}}

==_Gráfico comparativo_==

|| *Versão* || *Naive* || *MMX* || *SSE2* ||
|| *32 bits (320x240)* || 169 || 1142 || 1606 ||
|| *32 bits (680x340)* || 58 || 384 || 452 ||

----

= RGB Adjust Filter =

<wiki:comment>
RGB Adjust Filter Grupo 14
</wiki:comment>

O RGB Adjust Filter, basicamente, multiplica os valores de cada um dos 3 bytes de cor (R,G,B) por um fator pré-definido. Em nossa aplicação, decidimos escolher os valores 1 para multiplicar o valor preexistente para o byte representante da cor Vermelha (R - ou seja, não será modificada), o valor 0.5 para multiplicar o byte representante da cor verde (G) e 0.25 para multiplicar o byte representante da cor azul (B).
Nesta implementação que realizamos, a cada vez em que o filto é acionado, a multiplicação das cores de cada pixel pelos valores pré-estabelecidos ocorre, o que implica que para análise da eficiência de cada uma das implementações, basta retirarmos uma linha do código na implementação do {{{ChildView.cpp}}}, próximo à linha 460, deixando-se assim:
{{{
	//Grupo 14
	if (m_bUseRGBAdjust) {
		m_pSurface->RGBAdjust();
		bContinue = TRUE;
		//m_bUseRGBAdjust = false;
	}

}}}

Retirando-se o 'm_bUseRGBAdjust = false' é que realizamos as medidas de desempenho. Achamos melhor deixar essa linha no código para se notar com maior clareza como funciona o filtro, senão o mesmo ficaria sendo executado ininterruptamente, o que daria a impressão de que nosso filtro apenas zera todas as componentes de cor, à exceção da vermelha.

Na sequência vão os códigos para as três implementações, todas nas versões 32 bits.

== _Naive_ ==

{{{

void CSurface::RGBAdjust()
{
	COLORREF cCur;		
	BYTE r, g, b;		//Variáveis que receberão os valores RGB

	//Loop para acessar todos os pixels da imagem
	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);		//pega um pixel da tela da posição [i,j]
			b = (BYTE)(GetRValue(cCur)/4);	//divide o valor do canal B por 4
			g = (BYTE)(GetGValue(cCur)/2);	//divide o valor do canal G por 2
			r = (BYTE)(GetBValue(cCur)/1);	//divide o valor do canal R por 1
			PointColor(j,i,RGB(r,g,b));		//reescreve na tela o pixel com os valores RGB modificados na posição [i,j]
		}
	}
}

}}}

== _MMX_ ==

{{{

void CMMXSurface32Intrinsic::RGBAdjust()
{
	int height = GetVisibleHeight()*2;
	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);
	ULONGLONG mascara = 0xFF;
	ULONGLONG pixel;
	ULONGLONG next;

	pixel = *(ULONGLONG *)pCur;
	do
	{
		int width = m_width;
		do
		{
			next = *(ULONGLONG *)(pCur+1);
			__asm
			{
				movq mm0, pixel	//mm0 = pixel atual
				pand mm0, mascara	//mm0 = a componente 'B'
				pxor mm5, mm5
				psrlq mm0, 2		//1 shift para a direita (divide por 4, sem precisão)

				movq mm1, pixel	//mm0 = pixel, novamente
				psrlq mm1, 8		//shift à direita para pegar a componente 'G' do pixel
				pand mm1, mascara
				psrlq mm1, 1	//1 shift para a direita (divide por 2, sem precisão) 

				movq mm2, pixel
				psrlq mm2, 16  //mm0 = a componente 'R'
				pand mm2, mascara
				psrlq mm2, 0		//1 shift para a direita (divide por 1, sem precisão)

				movq mm3, pixel	//mm3 = pixel

				pxor mm4, mm4       //garante que o registrador mm4 esta vazio
				paddd mm4, mm3      //adiciona o canal alpha ao mm4
				psllq mm4, 8        //shift para o proximo byte
				paddd mm4, mm2      //copia o canal R (mm2) para mm4
				psllq mm4, 8		//um shift para esquerda em 1 byte
				paddd mm4, mm1		//copia o canal G (mm1) para mm4
				psllq mm4, 8		//novamente um shift para esquerda em 1 byte
				paddd mm4, mm0		//copia o canal B (mm0) para mm4
				movq pixel, mm4
				}
			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);
	} while (--height > 0);

}

}}}

== _SSE(n)_ ==


{{{

void CSSE2Surface32Intrinsic::RGBAdjust()
{
	int height = GetVisibleHeight()*2;				//aumenta a altura em 2 pois são processados 2 pixels de 32-bits de uma só vez em variáveis de 128 bits	
	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	//ponteiro para posição atual da tela

	ULONGLONG mascara = 0xFF;						//máscara para selecionar um byte por vez
	ULONGLONG pixel1, pixel2;						//variaveis de 64 bits que receberão valores de dois pixels consecutivos
	ULONGLONG next1, next2;							//variáveis que guardam a próximas posições de pixel1 e pixel2

	pixel1 = *(ULONGLONG *) pCur;					//pixel1 recebe pixel que está sendo apontado no inicio (0,0) 
	pixel2 = *(ULONGLONG *) (pCur+1);				//pixel2 recebe pixel consecutivo (0,1)

	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {

			next1 = *(ULONGLONG *) (pCur+2);		//guarda próximo valor para pixel1	
			next2 = *(ULONGLONG *) (pCur+3);		//guarda próximo valor para pixel2	

			__asm{
					movq xmm0, pixel1					//move pixel1 para os 64 bits menos significativos de xmm0 (128 bits)
					movhpd xmm0, pixel2					//move pixel2 para os 64 bits mais significativos de xmm0

					movq xmm1, mascara					//xmm1 fará o papel de seletor de bytes especificos de xmm0
					pand xmm1,xmm0						
					movq xmm2,xmm1                      //isola o canal B de pixel1 em xmm2
					psrld xmm2,2                      //dividindo por 4

					movq xmm1,mascara					
					psrldq xmm0,1						//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
					pand xmm1,xmm0
					movq xmm3,xmm1						//isola o canal G de pixel1 em xmm3
					psrld xmm3,1                      //dividindo por 2

					movq xmm1,mascara
					psrldq xmm0,1						//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
					pand xmm1,xmm0
					movq xmm4,xmm1						//isola o canal R de pixel1 em xmm4
					psrld xmm4,0                       //dividindo por 1

					psrldq xmm0,2						//desloca em 2 (pula o alpha) para direita xmm0, para selecionar agora sua metade mais significativa (pixel2)

					movq xmm1,mascara
					pand xmm1,xmm0
					movq xmm5,xmm1						//isola o canal B de pixel2 em xmm5
					psrld xmm5,2                      //dividindo por 4

					movq xmm1,mascara
					psrldq xmm0,1
					pand xmm1,xmm0
					movq xmm6,xmm1						//isola o canal G de pixel2 em xmm6
					psrld xmm6,1                       //dividindo por 2

					movq xmm1,mascara
					psrldq xmm0,1
					pand xmm1,xmm0
					movq xmm7,xmm1						//isola o canal R de pixel2 em xmm7
					psrld xmm7,0                       //dividindo por 1

					pxor xmm0,xmm0					// zera o registrador que vai receber os resultados

					paddq xmm0,xmm4					// R de pixel1
					pslldq xmm0,1					// proxima posição
					paddq xmm0,xmm3					// G de pixel1
					pslldq xmm0,1					// proxima posição
					paddq xmm0,xmm2					// B de pixel1
					movq pixel1,xmm0				// atualiza o valor de pixel1

					pxor xmm0,xmm0					// zera o registrador que vai receber os resultados

					paddq xmm0,xmm7					// R de pixel2
					pslldq xmm0,1					// proxima posição
					paddq xmm0,xmm6					// G de pixel2
					pslldq xmm0,1					// proxima posição
					paddq xmm0,xmm5					// B de pixel2
					movq pixel2,xmm0				// atualiza o valor de pixel2
			}

			*(ULONGLONG *)pCur = pixel1;			//joga o valor calculado de pixel1 de volta na tela
			*(ULONGLONG *)(pCur+1) = pixel2;		//joga o valor calculado de pixel2 de volta na tela
			pixel1 = next1;							//pixel1 recebe o próximo pixel 
			pixel2 = next2;							//pixel2 recebe o próximo pixel
			pCur += 2;								//aumenta o ponteiro da tela em 2 (calcula 2 pixels por vez)
		} while (--width > 0);
	} while (--height > 0); 
}

}}}


As tomadas da quantidade de frames por segundo que vêm nos gráficos abaixo surgiram da aplicação do filtro em imagens estáticas, sem nenhum outro filtro aplicado simultaneamente.

==_Gráfico comparativo_==

http://img580.imageshack.us/img580/8223/chartqs.png

----

= Gradient Filter =

<wiki:comment>
Gradient Filter Grupo 8
</wiki:comment>

O Filtro Gradiente pode escurecer ou clarear uma parte da imagem (de forma gradiente e não completamente), dependendo da implementação feita.  Esse filtro tem como objetivo alterar a variação da luz na imagem, sendo que a transformação aplicada depende sempre da luminosidade no objeto, e assim o filtro pode ser aplicado de forma coerente.
No início do século XX, o filtro gradiente era muito utilizado, por exemplo, para escurecer céus em fotos de paisagens, como na imagem abaixo.

http://img819.imageshack.us/img819/359/gradientdark.jpg

Na foto acima é possível verificar a forte diferença de luminosidade entre o céu e a terra, e quando foi tirada, o céu se encontrava nublado e não havia sol. Para esse exemplo o filtro escureceu a imagem e foi utilizado 2 vezes consecutivas

Em nossas implementações foi utilizado o gradiente que clareia a imagem, somando o valor RGB pela sua metade atual, e foram feitas nas versões “Naive”, “MMX” e “SSE(n)”. A foto abaixo ilustra, oque acontece quando o filtro é aplicado.

http://img806.imageshack.us/img806/3876/clearing.png

== _Naive_ ==

Na implementação Naive,  o valor de cada pixel é somado com a metade do valor obtido na posição atual do pixel para todos os valores de R (GetRValue(cCur)) + i/2), G (GetGValue(cCur)) + i/2)  e B (GetBValue(cCur)) + i/2) e caso a soma ultrapasse 255, o valor 255 é aplicado. 

{{{
void CSurface::Gradient()
{
	COLORREF cCur;		//declara um dword
	BYTE r, g, b;		//variáveis tipo byte que receberão os valores RGB

	//realiza um loop dentro do outro para percorrer a tela inteira
	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);		//pega um pixel da tela da posição [i,j]	
			
			r = ((BYTE)(GetRValue(cCur)) + i/2) > 255 ? 255 :(BYTE)(GetRValue(cCur)) + i/2;
			g = ((BYTE)(GetGValue(cCur)) + i/2) > 255 ? 255 :(BYTE)(GetGValue(cCur)) + i/2;
			b = ((BYTE)(GetBValue(cCur)) + i/2) > 255 ? 255 :(BYTE)(GetBValue(cCur)) + i/2;

			PointColor(j,i,RGB(b,g,r));		//reescreve na tela o pixel do valores RGB modificados na posição [i,j]
		}
	}
}

}}}


== _MMX_ ==

{{{
void CMMXSurface32Intrinsic::Gradient()
{
	int contador2 = 1;	//contador auxiliar usado de base para o contador principal
	int contador;		//contador principal que fará o incremento de cada canal
	int height = GetVisibleHeight()*2;	//altura multiplicada por 2 pois são pixels de 32 bits em variáveis de64 bits (2x maior)
	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xFF;	//seleciona um byte de alguma variável (utilizada para pegar valores individuais de RGB)
	ULONGLONG pixel;	//recebe os valores referentes a um ponto da tela
	ULONGLONG next;		//recebe os valores do próximo ponto a partir de pixel 

	pixel = *(ULONGLONG *)pCur;	//faz um casting 64 bits dos dados do ponto atual na variável pixel

	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			next = *(ULONGLONG *)(pCur+1);	//próximo ponto recebe o ponteiro que aponta para um ponto na tela + 1
			contador = contador2/3;			//O contador principal recebe o contador auxiliar/3 para que a gradiência não aconteça tão rápido

			//utilização dos registradores mmx 64 bits com inline assembly 
			__asm{
				movq mm0, pixel		//registrador mm0 recebe o valor do pixel atual
					pand mm0, mascara	//valor de mm0 recebe uma mascara para selecionar seu 1 byte menos significativo (B)
					paddusb mm0, contador

					movq mm1, pixel		//registrador mm1 recebe o valor do pixel atual
					psrlq mm1, 8		//realiza um shift lógico para direita para pegar o 2 byte
					pand mm1, mascara	//valor de mm1 recebe uma mascara para selecionar seu 2 byte menos significativo (G)
					paddusb mm1, contador

					movq mm2, pixel		//registrador mm2 recebe o valor do pixel atual
					psrlq mm2, 16		//realiza um shift lógico para direita para pegar o 3 byte
					pand mm2, mascara	//valor de mm2 recebe uma mascara para selecionar seu 1 byte menos significativo (R)
					paddusb mm2, contador

					movq mm3, pixel     // mm3 <- pixel atual
					psrlq mm3, 24       // mm3 <- canal alpha

					pxor mm4, mm4       //garante que o registrador mm4 esta vazio
					paddd mm4, mm3      //adiciona o canal alpha ao mm4
					psllq mm4, 8        //shift para o proximo byte
					paddd mm4, mm2      //copia o canal R (mm2) para mm4
					psllq mm4, 8		//um shift para esquerda em 1 byte
					paddd mm4, mm1		//copia o canal G (mm1) para mm4
					psllq mm4, 8		//novamente um shift para esquerda em 1 byte
					paddd mm4, mm0		//copia o canal B (mm0) para mm4

					movq pixel, mm4     //retorna para a variavel alto nivel os novos valores do pixel
			}

			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);

		if (contador<255)
			contador2++;

	} while (--height > 0);
}

}}}


== _SSE(n)_ ==


-----

= Channel Mix Filter =

<wiki:comment>
ChannelMix Grupo 11
</wiki:comment>

O filtro Channel Mix pode ser definido como a mistura dos canais RGB de uma imagem. Neste filtro, cada canal recebe a mistura dos outros dois canais, alterando as cores finais da imagem.
Para obter a mistura de dois canais, extraímos o valor de outro sistema de cores, o CMYK, onde C (Cyan) é a mistura dos canais G e B (Green e Blue), M (Magenta) é a mistura dos canais B e R (Blue e Red) e Y (Yellow) é a mistura dos canais R e G (Red e Green).
A imagem abaixo ajuda a compreender as alterações feitas.

http://www.rpdesigner.com.br/wp-content/uploads/2011/03/rgb-vs-cmyk-comparacao.jpg

Resumidamente, o processo ocorre de tal maneira:
A mistura dos canais R-G (Y) é colocado no lugar de B,  G-B (C) é colocado em R e B-R (M) é colocado em G.

==_Naive_==

Nesta implementação extraimos os valores de cada canal do sistema CMYK. Estes valores são atribuídos a 3 variáveis (r,g e b) correspondentes ao sistema RGB.
Por exemplo, o comando  "r = (BYTE)(GetCValue(cCur));" atribui à variável r o valor de C, que é a mistura dos canais G e B.

{{{
void CSurface::ChannelMix()
{
	COLORREF cCur;
	BYTE r, g, b;

	for(int i=0; i < m_wndHeight; i++){
		for(int j=0; j < m_wndWidth; j++){
			cCur = PointColor(j,i);

			r = (BYTE)(GetCValue(cCur));
			g = (BYTE)(GetMValue(cCur));
			b = (BYTE)(GetYValue(cCur));
			
			PointColor(j,i,RGB(b,g,r));
		}
	}
}
}}}


==_MMX_==



==_SSE(n)_==

-----
= Invert Filter =
<wiki:comment>
Invert Filter Grupo 7
</wiki:comment>
http://img860.imageshack.us/img860/7507/invertfilter.jpg
<br />
O Invert Filter realiza a inversão das cores da imagem.
Para a aplicação do filtro foi necessário pegar cada pixel dividido em seus quatro canais (alpha,R,G,B) e realizar uma subtração de 255 para a inversão da cor atual.
----
==_Naive_==
A implementação "ingênua" do Invert Filter foi realizada pegando-se cada pixel (4 bytes) e subtraindo-se 255 de cada canal de cores.
{{{
void CSurface::Invert(){
	COLORREF cCur;	 //declara um dword
	BYTE r, g, b;	//variáveis tipo byte que receberão os valores RGB                    
        //realiza um loop dentro do outro para percorrer a tela inteira
	for (int i = 0; i < m_wndHeight; i++) {
	      for (int j = 0; j < m_wndWidth; j++) {
	        cCur = PointColor(j,i);      //pega o pixel de posição [i,j] na tela
		r = (BYTE)(255 - GetRValue(cCur));	
		g = (BYTE)(255 - GetGValue(cCur));
		b = (BYTE)(255 - GetBValue(cCur));
               //reescreve na tela o pixel do valores RGB modificados na posição [i,j]
		PointColor(j,i,RGB(b,g,r));   
	      }
	}
}
}}}
----
==_MMX_==
Esta implementação utilizou inline assembly para acessar os registradores de 64 bits mmx. A ideia do código é simples: através de uma máscara com o valor de 255 (0xFF) os valores RGB foram subtraídos. Com isso o valor do pixel atual é modificado como sendo sua respectiva cor inversa.
Nesta implementação, 2 pixels são calculados a cada iteração.
{{{
void CMMXSurface32Intrinsic::Invert()
{
    ULONGLONG mascara = 0xFFFFFFFFFFFFFFFF;		//o valor do pixel sera subtraido dessa mascara

	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);
	ULONGLONG pixels;

	int height = GetVisibleHeight();
	while (height--)
	{
		int width = m_width;	//m_width = (width+1)/2; pois editamos 2 pixels por iteracao
		while(width--)
		{
			pixels = *(ULONGLONG *)pCur;

			__asm
			{
					movq mm0, pixels	// registrador mm0 recebe 2 pixels
					movq mm1, mascara	// registrador mm1 recebe valor da mascara
					psubb mm1, mm0		// mascara - pixel1 e mascara - pixel2
					movq pixels, mm1    // pixel recebe os dois pixels já invertidos
			}

			// Imprime dois pixels na tela
			*(ULONGLONG *)pCur = pixels;

			pCur += 2;
		}
	}
}
}}}
----
==_SSE2_==
Na implementação SSE2, 4 pixels são calculados a cada iteração nos registradores xmm de 64 bits, o que demonstrou uma gradação mais eficiente a cada tecnologia utilizada.
{{{
void CSSE2Surface32Intrinsic::Invert()
{
    ULONGLONG mascara = 0xFFFFFFFFFFFFFFFF;		//o valor do pixel sera subtraido dessa mascara

	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);
	ULONGLONG pixels12, pixels34;


	int height = GetVisibleHeight();
	while (height--)
	{
		int width = m_width;
		while(width--)
		{
			pixels12 = *(ULONGLONG *)pCur;
			pixels34 = *(ULONGLONG *)(pCur+2);

			__asm {

				movq xmm0, pixels12		// xmm0 recebe 2 pixels em sua metade inferior
				movhpd xmm0, pixels34	// xmm0 recebe 2 pixels em sua metade superior

				// xmm1 recebe a mascara a ser aplicada em 4 pixels simultaneamente
				movq  xmm1, mascara
				movhpd xmm1, mascara

				psubb xmm1, xmm0			// aplica mascara

				movq pixels12, xmm1
				movhpd pixels34, xmm1
			}

			// Imprime quatro pixels na tela
			*(ULONGLONG *)pCur = pixels12;
			*(ULONGLONG *)(pCur+2) = pixels34;

			pCur += 4;
		}
	}
}
}}}
----
==_Gráfico Comparativo_==
Pelo gráfico, nota-se o desempenho da tecnologia SSE2 como sendo superior à MMX e Naive, visto que a quantidade de cálculos em paralelo foi dobrando a cada nível de implementação (Naive > MMX > SSE2).<br/>
http://img842.imageshack.us/img842/1623/benchmarkinvertfilter.png

= Rescale Filter =

<wiki:comment>
Rescale Filter Grupo 17
</wiki:comment>

Descrição...........

A seguir estão os códigos, todos implementados na versão 32 bits.

== _Naive_ ==



== _MMX_ ==


== _SSE2_ ==


==_Gráfico comparativo_==

http://img35.imageshack.us/img35/1246/graficocomparativo.jpg

----

= Gray Filter =
<wiki:comment>
Gray Filter - Grupo 12
</wiki:comment>

Este filtro produz um efeito “desabilitado” na imagem, o que por vezes
resulta em uma versão “acinzentada” da mesma.
----
==_Exemplo de aplicação_==
Temos abaixo, a imagem original, sem efeitos aplicados:

http://img834.imageshack.us/img834/8491/dilma.png

Na imagem abaixo, aplicamos o Gray Filter apenas uma vez:

http://img841.imageshack.us/img841/1952/dilmaj.png

O resultado de muitas aplicações do filtro seria uma imagem totalmente branca.

----
==_Naive_==
Funciona tirando a média dos valores R, G e B de cada pixel com o Branco. Não contém parâmetros.
{{{
void CSurface::GrayFilter()
{
	COLORREF cCur;		//declara um dword
	BYTE r, g, b;		//variáveis tipo byte que receberão os valores RGB


	//realiza um loop dentro do outro para percorrer a tela inteira
	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);			//pega o pixel de posição [i,j] na tela
			r = (BYTE)((GetRValue(cCur)+255)/2);	//realiza média do canal R com o branco e atualiza
			g = (BYTE)((GetGValue(cCur)+255)/2);	//realiza média do canal G com o branco e atualiza
			b = (BYTE)((GetBValue(cCur)+255)/2);	//realiza média do canal B com o branco e atualiza
			PointColor(j,i,RGB(b,g,r));		//reescreve na tela o pixel do valores RGB modificados na posição [i,j]
		}
	}
}

}}}
----
==_MMX_==
Neste código utiliza-se o inline assembly para ter acesso aos registradores de 64 bits MMX. 
Funcionalidade do código: através de uma máscara que seleciona um byte por vez, os valores RGB são extraídos e uma média com o Branco é feita, com isso o valor do pixel atual é modificado, gerando um tom acinzentado.
{{{
void CMMXSurface32Intrinsic::GrayFilter(){

    int height = GetVisibleHeight()*2;	//altura multiplicada por 2 pois são pixels de 32 bits em variáveis de64 bits (2x maior)
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xFF;	//seleciona um byte de alguma variável (utilizada para pegar valores individuais de RGB)
	ULONGLONG pixel;	//recebe os valores referentes a um ponto da tela
	ULONGLONG next;		//recebe os valores do próximo ponto a partir de pixel 
	
	pixel = *(ULONGLONG *)pCur;	//faz um casting 64 bits dos dados do ponto atual na variável pixel
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next = *(ULONGLONG *)(pCur+1);	//próximo ponto recebe o ponteiro que aponta para um ponto na tela + 1
			
			//utilização dos registradores mmx 64 bits com inline assembly 
			__asm{
				movq mm0, pixel		//registrador mm0 recebe o valor do pixel atual
				pand mm0, mascara	//valor de mm0 recebe uma mascara para selecionar seu 1 byte menos significativo (B)
				paddd mm0, mascara //acresce 255d a B
				psrlq mm0, 1        //1 shift para a direita (divide por 2, sem precisão)

				movq mm1, pixel		//registrador mm1 recebe o valor do pixel atual
				psrlq mm1, 8		//realiza um shift lógico para direita para pegar o 2 byte
				pand mm1, mascara	//valor de mm1 recebe uma mascara para selecionar seu 2 byte menos significativo (G)
				paddd mm1, mascara //acresce 255d a G
				psrlq mm1, 1        //1 shift para a direita (divide por 2, sem precisão)

				movq mm2, pixel		//registrador mm2 recebe o valor do pixel atual
				psrlq mm2, 16		//realiza um shift lógico para direita para pegar o 3 byte
				pand mm2, mascara	//valor de mm2 recebe uma mascara para selecionar seu 1 byte menos significativo (R)
				paddd mm2, mascara //acresce 255d a R
				psrlq mm2, 1        //1 shift para a direita (divide por 2, sem precisão)

				movq mm3, pixel     // mm3 <- pixel atual
				psrlq mm3, 24       // mm3 <- canal alpha

				pxor mm4, mm4       //garante que o registrador mm4 esta vazio
				paddd mm4, mm3      //adiciona o canal alpha ao mm4
				psllq mm4, 8        //shift para o proximo byte
				paddd mm4, mm2      //copia o canal R (mm2) para mm4
				psllq mm4, 8		//um shift para esquerda em 1 byte
				paddd mm4, mm1		//copia o canal G (mm1) para mm4
				psllq mm4, 8		//novamente um shift para esquerda em 1 byte
				paddd mm4, mm0		//copia o canal B (mm0) para mm4

				movq pixel, mm4     //retorna para a variavel alto nivel os novos valores do pixel
			}

			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);
	} while (--height > 0);
}

}}}
----
==_SSE2_==
Neste código utiliza-se inline assembly para acessar os registradores de 128 bits SSE. Basicamente é a mesma funcionalidade aplicada para a implementação em MMX, a diferença é que dois pixels são processados de uma vez ao invés de um por um a cada loop, promovendo certo ganho de desempenho.
{{{
void CSSE2Surface32Intrinsic::GrayFilter()
{
	int height = GetVisibleHeight()*2;				//aumenta a altura em 2 pois são processados 2 pixels de 32-bits de uma só vez em variáveis de 128 bits	
	DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	//ponteiro para posição atual da tela

	ULONGLONG mascara = 0xFF;						//máscara para selecionar um byte por vez
	ULONGLONG pixel1, pixel2;						//variaveis de 64 bits que receberão valores de dois pixels consecutivos
	ULONGLONG next1, next2;							//variáveis que guardam a próximas posições de pixel1 e pixel2

	pixel1 = *(ULONGLONG *) pCur;					//pixel1 recebe pixel que está sendo apontado no inicio (0,0) 
	pixel2 = *(ULONGLONG *) (pCur+1);				//pixel2 recebe pixel consecutivo (0,1)

	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {

			next1 = *(ULONGLONG *) (pCur+2);		//guarda próximo valor para pixel1	
			next2 = *(ULONGLONG *) (pCur+3);		//guarda próximo valor para pixel2	

			__asm{
				movq xmm0, pixel1			//move pixel1 para os 64 bits menos significativos de xmm0 (128 bits)
				movhpd xmm0, pixel2			//move pixel2 para os 64 bits mais significativos de xmm0

				movq xmm1, mascara			//xmm1 fará o papel de seletor de bytes especificos de xmm0
				pand xmm1,xmm0						
				movq xmm2,xmm1                      	//isola o canal B de pixel1 em xmm2
				movq xmm1, mascara
				paddq xmm2, xmm1		   	//adiciona 255 ao canal B
				psrld xmm2,1                       	//dividindo por 2

				movq xmm1,mascara					
				psrldq xmm0,1				//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
				pand xmm1,xmm0
				movq xmm3,xmm1				//isola o canal G de pixel1 em xmm3
				movq xmm1, mascara
				paddq xmm3, xmm1			//adiciona 255 ao canal G
				psrld xmm3,1                       	//dividindo por 2

				movq xmm1,mascara
				psrldq xmm0,1				//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
				pand xmm1,xmm0
				movq xmm4,xmm1				//isola o canal R de pixel1 em xmm4
				movq xmm1, mascara
				paddq xmm4, xmm1			//adiciona 255 ao canal R
				psrld xmm4,1                       	//dividindo por 2

				psrldq xmm0,2				//desloca em 2 (pula o alpha) para direita xmm0, para selecionar agora sua metade mais significativa (pixel2)

				movq xmm1,mascara
				pand xmm1,xmm0
				movq xmm5,xmm1				//isola o canal B de pixel2 em xmm5
				movq xmm1, mascara
				paddq xmm5, xmm1			//adiciona 255 ao canal B
				psrld xmm5,1                      	//dividindo por 2
					
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				movq xmm6,xmm1				//isola o canal G de pixel2 em xmm6
				movq xmm1, mascara
				paddq xmm6, xmm1			//adiciona 255 ao canal G
				psrld xmm6,1                       	//dividindo por 2

				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				movq xmm7,xmm1				//isola o canal R de pixel2 em xmm7
				movq xmm1, mascara
				paddq xmm7, xmm1			//adiciona 255 ao canal R
				psrld xmm7,1                       	//dividindo por 2

				pxor xmm0,xmm0				// zera o registrador que vai receber os resultados

				paddq xmm0,xmm4				// R de pixel1
				pslldq xmm0,1				// proxima posição
				paddq xmm0,xmm3				// G de pixel1
				pslldq xmm0,1				// proxima posição
				paddq xmm0,xmm2				// B de pixel1
				movq pixel1,xmm0			// atualiza o valor de pixel1

				pxor xmm0,xmm0				// zera o registrador que vai receber os resultados

				paddq xmm0,xmm7				// R de pixel2
				pslldq xmm0,1				// proxima posição
				paddq xmm0,xmm6				// G de pixel2
				pslldq xmm0,1				// proxima posição
				paddq xmm0,xmm5				// B de pixel2
				movq pixel2,xmm0			// atualiza o valor de pixel2
			}

			*(ULONGLONG *)pCur = pixel1;			//joga o valor calculado de pixel1 de volta na tela
			*(ULONGLONG *)(pCur+1) = pixel2;		//joga o valor calculado de pixel2 de volta na tela
			pixel1 = next1;					//pixel1 recebe o próximo pixel 
			pixel2 = next2;					//pixel2 recebe o próximo pixel
			pCur += 2;					//aumenta o ponteiro da tela em 2 (calcula 2 pixels por vez)
		} while (--width > 0);
	} while (--height > 0); 
}
}}}
----
==_Observações_==

Ocorreram problemas quando colocamos uma imagem e utilizamos o filtro com o Swarm ainda ligado, pois ele faz com que o filtro seja aplicado diversas vezes devido aos frames de sua troca de imagem. Com isso, foram feitas algumas alterações no arquivo ChildView.cpp:  foi adicionado uma variável booleana que verifica se o Swarm está desligado ou não, caso positivo(desligado), a variável recebe verdadeiro e aciona o filtro na imagem escolhida. A seguir apresentamos parte do código em que foi utilizada tal variável.
{{{
BOOL CChildView::OnIdle(LONG /*lCount*/)
{
	//Grupo 12
	if (m_bUseGrayF && !execGray) {
		if(m_bPauseSwarm){
			execGray = true;
		}
		m_pSurface->GrayFilter();
		bContinue = TRUE;
	}
}

void CChildView::OnUpdateUseGrayF(CCmdUI* pCmdUI)
{
	if (pCmdUI->m_nID == ID_INDICATOR_USE_GRAYF) {
		pCmdUI->Enable(m_bUseGrayF ? FALSE : TRUE);
	}
	else {
		ASSERT(pCmdUI->m_nID == ID_VIEW_USE_GRAYF);
		pCmdUI->SetCheck(m_bUseGrayF ? 1 : 0);
		pCmdUI->Enable(TRUE);
	}
}
}}}
----

==_Gráfico Comparativo_==
Pudemos observar que no caso do nosso efeito, a versão MMX não nos deu ganho superior à versão Naive. Porém, na implementação SSE pudemos perceber um aumento significativo de desempenho. 
O gráfico abaixo nos mostra o desempenho das versões para resolução da tela em 320x240:<br/>
http://img97.imageshack.us/img97/8538/chart1.png

----