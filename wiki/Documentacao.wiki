#summary Documentação das funcionalidades implementadas no programa.
#labels Phase-Implementation,Phase-Design

= Introdução =

O objetivo deste projeto é disponibilizar implementações que possam ser usadas para comparar o desempenho das instruções de multimídia nas arquiteturas Intel(r).

O código original do programa pode ser baixado em [http://msdn.microsoft.com/en-us/library/0aws1s9k(v=vs.80).aspx]

----

= Versões 16, 24 e 32 bits =

<wiki:comment>
Grupo 1
Descrever as diferenças de desempenho e em quais implementações se aplicam. (Normal, MMX e SSE)
</wiki:comment>

A análise de desempenho entre as versões de 16, 24 e 32 bits é feita a partir dos códigos-fonte das implementações: Naive, MMX e SSE2.

Primeiramente é importante conhecer a parte teórica referente a cada conjunto de instruções. 

<b>Naive</b>

Trata-se da implementação básica, pois não utiliza um conjunto de instruções específicos para otimização.

<b>MMX</b>

Conjunto de instruções criado pela Intel para aplicações multimídia com a finalidade de aumentar performance. Ele é voltado para a melhora na execução de operações em grandes vetores de dados.
Implementa o modelo de execução SIMD (Single Instruction Multiple Data) pois assim quando se trabalha com arquivos multimídia são utilizados grandes vetores de dados de modo a agilizar a leitura e processamento devido aos registradores de 64 bits.

<b>SSE2</b>

Trata-se do sucessor do MMX e permite aumentar performance em operações de ponto flutuante. Extende as operações do MMX para registradores XMM (64 bits) o que permite ao programador evitar os registradores MM, que não possuem suporte específico para operações de ponto flutuante, fornecendo maior precisão.

===Análise de performance===

Os programas em MMX e SSE2 usam recursos para aumentar a performance das operações e movimentações de informações: utilizam os registradores estendidos de 64 bits para executar várias instruções em um grande vetor de dados em um tempo reduzido, em comparação com os registradores usuais da linguagem. No caso do programa em questão, os registradores são usados para obtenção de vários pixels na tela de uma só vez, e baseado nessas localizações, fazer as operações necessárias em todos estes lugares.

*MMX-16*

O código MMX para cores com 16 bits de profundidade consiste em:

1.Passar o endereço do pixel da posição corrente para uma variável pCur, no formato ULONGLONG(64bits).

2.Por manipulação deste ponteiro, obter as posições dos pixels ao redor (cUp, cDown, cLeft, cRight, cCur) e compará-los a uma máscara previamente inicializada para editar os bits das posições relevantes à cor.

Após isto, as cores dos pixels ao redor são usadas na modificação desejada (no caso, estamos analisando o efeito Blur). A distribuição das cores é feita entre os pixels, e a próxima posição desejada é calculada. A operação é repetida.

*MMX-24*

O código MMX para cores com 24 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato DWORD. 

2.Cria-se uma variável de 64 bits cFader, que será usada nas operações para a modificação dos valores dos pixels. Isto é feito a partir de uma operação chamada UnpackBytesLo de forma simplificada ele pega a dword que pCur aponta e faz um tipo de concatenação com uma dword cheia de zeros da seguinte forma: suponha que pCur aponta pra dword ff0a0b0c. Neste caso, 0a0b0c representa o RGB do pixel e ff sua transparência. Quando se chama cCur.UnpackBytesLo ( *pCur ), ele empacota na variável cCur uma QWORD 00ff000a000b000c, ou seja, ele faz uma "mescla" byte a byte do vetor passado como referência com um vetor de zeros. Então, as operações feitas neste registrador são feitas duas vezes mais (como se fossem feitas em um bit válido e um bit que sempre está em zero). Isto rende uma perda de performance.

3.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes são "desempacotados" e usados nas operações de modificação de cores. Calcula-se o próximo pixel e repete-se o passo 3.

*MMX-32*

O código MMX para cores com 32 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG. 

2.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes(contando com os pixels da diagonal direita superior, diagonal direita inferior e o segundo pixel da direita) são "desempacotados" e usados nas operações de modificação de cores. 

3.Depois das modificações das cores, os pixels são reempacotados em uma variável de 64 bits. Repetem-se os passos 2 e 3.

_Observações sobre MMX:_

Todas as operações em MMX envolvem o uso de instruções de empacotamento de bytes. Estas instruções tem alguns pontos onde a performance do sistema é afetada por operações desnecessárias nos pixels. Por exemplo, o PUNPCKLBW, instrução MMX para o desempacotamento de uma DWORD, gera bits zerados que não contribuem para o programa, e que entram em loops e operações supérfluas.

Podemos ver pela performance dos códigos em MMX que estes não são eficientes neste programa, sendo mais lentos que a implementação Naive e a SSE2.

*SSE2-16*

Este código processa cada pixel em uma WORD, carregando poucos dados em cada uma de suas execuções, fazendo com que sua performance seja diminuída.

1.Passar o endereço da posição corrente para uma variável pCur, no formato __m128i.

2.Por meio de manipulações neste ponteiro, podemos obter as posições dos pixels adjacentes (cDownBase, etc). Estas posições são passadas por uma máscara: cada parte de 16 bits de um pixel tem os últimos cinco bits reservados para as informações de cor (cDown, cUp, etc).

3.Após isto, ele executa as operações matemáticas para no pixel corrente e nos dois próximos pixels à direita. Avança o ponteiro e repetem-se os dois passos.

*SSE2-24*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Com base neste ponteiro corrente, desempacota-o para obter os pixels adjacentes, e executa as operações matemáticas nas cores da posição corrente.

3.Avança o ponteiro, e re-executa o passo 2.

4.O resultado é empacotado na posição do ponteiro corrente. Avança o ponteiro, e recomeça o processo do passo 2.

*SSE2-32*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Fazemos o casting deste ponteiro para o tipo RGBQUAD, que é formado por: três Bytes que fazem referência às cores vermelha, verde e azul, e um Byte reservado. O próximo ponteiro é definido aqui também.

3.Fazemos as operações matemáticas para definir a cor do pixel corrente, e do próximo. O cFader entra logo depois, aumentando ou diminuindo o tom da cor.

4.Empacotamos a cor do pixel corrente no seu ponteiro, e avançamos o pCur. Recomeça o processo a partir do 2.

=== Estudando o desempenho ===

Numa primeira análise observamos as linhas de código (LOC) das implementações MMX e SSE2. Porém sabemos que trata-se apenas de um indicador de performance e não nos dá uma ideia precisa das reais diferenças entre as implementações. As linhas de código do Naive não foram consideradas, pois não apresentam diferença nenhuma.

|| *Versão* || *MMX* || *SSE2* ||
|| *16 bits*|| 538 LOC  || 533 LOC ||
|| *24 bits*|| 204 LOC || 301 LOC || 
|| *32 bits*|| 283 LOC || 311 LOC ||


Já o gráfico a seguir mostra os resultados de testes feitos usando o código fornecido no repositório para os três conjuntos de instruções citados.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,105&chxs=0,676767,11.5,0,lt,676767&chxt=y,x&chbh=a,5,10&chs=600x300&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,100,0,100,0,105&chd=t:87,84,89|42,77,70|66,105,88&chdl=Naive|MMX|SSE2&chtt=Gr%C3%A1fico+de+Desempenho+(FPS)&fake=name.png

|| *Versão* || *Naive* || *MMX* || *SSE2* ||
|| *16 bits* || 87 || 42 || 66 ||
|| *24 bits* || 84 || 77 || 105 ||
|| *32 bits* || 89 || 70 || 88 ||

Obs1: Valores do eixo y em frames per second (fps) e testados em resolução 320x240.

Obs2: Valores possuem certa variância devido ao fato do computador estar executando outras tarefas.

=== Conclusões ===

Após o estudo do funcionamento dos algoritmos e da análise de desempenho de cada um, podemos verificar que a implementação SSE-2 em 24 bits é a que possui melhor desempenho (fps) em relação aos demais.Como o SSE-2 é uma versão avançada do MMX (MMX -> SSE -> SSE-2), não é surpresa tal diferença na performance.

Com relação às implementações restantes, podemos ver que o MMX não foi devidamente implementado, ou seja, poderia ter melhor desempenho se devidamente otimizado.

Por fim, podemos afirmar que a implementação Naive possuí uma performance acima da média, uma vez que a única versão que supera seu desempenho é a SSE-2 de 24 bits.


----

= Implementações =

<wiki:comment>
Grupo 2
Descrever Blur, Blit e Swarm nas três versões (Normal, MMX e SSE).
</wiki:comment>

== Blur/Smooth (Borrar) ==

Este efeito é obtido por meio da média do pixel com seus vizinhos, porém o pixel central tem peso maior, deixando um rastro que ao passar do tempo (dos cálculos da média) vai desaparecendo.
Desta maneira, ao pausar o BLUR, as Llamas do SWARM tendem a acelerar instantaneamente, pois é pausado todos os cálculos de desempacotamento, leitura, e operações matematicas, permitindo com que a capacidade de processamento possa ser utilizada por completa na movimentação das Llamas.

=== _Naive_ ===

Nesta implementação o valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) e dividido por 8 (>> 3).

{{{
void CSurface::BlurBits()
{
    COLORREF cLeft = 0, cCur = PointColor(0,0), cRight, cUp, cDown;
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        cLeft = 0;
        for (int j = 0; j < m_wndWidth; j++) {
            cRight = PointColor(j+1, i);
            cUp = PointColor(j, i-1);
            cDown = PointColor(j, i+1);
            r = (BYTE)(((int)(GetRValue(cCur) << 2) + GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) >> 3);
            g = (BYTE)(((int)(GetGValue(cCur) << 2) + GetGValue(cLeft) + GetGValue(cRight) + GetGValue(cUp) + GetGValue(cDown)) >> 3);
            b = (BYTE)(((int)(GetBValue(cCur) << 2) + GetBValue(cLeft) + GetBValue(cRight) + GetBValue(cUp) + GetBValue(cDown)) >> 3);
            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
            cLeft = cCur;
            cCur = cRight;
        }
    }
}
}}}

=== MMX ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CMMXSurface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);

	CMMX cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CMMX cUp, cDown, cCur, cLeft, cRight;
	CMMX cDest;
	CMMX cMask(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase = *(ULONGLONG*)(pwCur-1);
			cCurBase = pCur[0];
			cRightBase = *(ULONGLONG*)(pwCur+1);
			cUpBase = pCur[-m_qwpl];
			cDownBase = pCur[+m_qwpl];

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			*pCur++ = cDest;
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores MMX sã0 de 64 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar MMX na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight;
	CMMX cLeft;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(DWORD *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(DWORD *)(bpCur+1) );
			*pCur++ = cUp.PackBytes();
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 2 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atrobuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown) .O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight, cRightRight;
	CMMX cDownRight;
	CMMX cLeft;
	CMMX cUpRight;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();
	cCur.UnpackBytesLo( *pCur );

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			cRight.UnpackBytesLo( pCur[1] );
			cRightRight.UnpackBytesLo( pCur[2] );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cUpRight.UnpackBytesLo( pCur[-m_dwpl+1] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );
			cDownRight.UnpackBytesLo( pCur[m_dwpl+1] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cDown = (cDownRight+cUpRight+cCur+cRightRight+(cRight<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
			cDown += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
    	    cDown -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
			cCur = cRightRight;
	
			*(ULONGLONG *)pCur = cUp.PackBytes(cDown);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

=== SSE(n) ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores MMX são de 128 bits, os dados podem ser alinhados, sendo possível manipular 8 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CSSE2Surface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    __m128i *pCur  = (__m128i *)GetPixelAddress(0,0);

	CSSE2 cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CSSE2 cUp, cDown, cCur, cLeft, cRight;
	CSSE2 cDest;
	CSSE2 cMask;
	cMask.Fill(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase.LoadU(pwCur-1);
			cCurBase.Load(pCur);
			cRightBase.LoadU(pwCur+1);
			cUpBase.Load(pCur-m_qqwpl);
			cDownBase.Load(pCur+m_qqwpl);

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			cDest.Store(pCur++);
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores MMX são de 128 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar MMX na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG*)GetPixelAddress(0,0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			pCur++;
			bpCur = (BYTE *)pCur;
			cCur.UnpackBytesLo( pCur[0] );
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
			cCur -= cFader; // increase the fade to white
			cResult -= cFader; // increase the fade to white
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			cResult.PackBytes(pCur-1, cCur);
			pCur++;
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores MMX são 128 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown).O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);
	ASSERT((DWORD_PTR(pCur) & 0xF) == 0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		ASSERT((DWORD_PTR(pCur) & 0xF) == 0);
		do {
			RGBQUAD *pdwCur = (RGBQUAD*)pCur;
			ULONGLONG *pNext = (ULONGLONG*)(pdwCur+1);

			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( *pCur );
			cRight.UnpackBytesLo( *pNext );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cLeft = cRight; 		// Slide left!
			cCur.UnpackBytesLo( pCur[1] );
			cRight.UnpackBytesLo( pNext[1] );
			cUp.UnpackBytesLo( pCur[-m_qwpl+1] );
			cDown.UnpackBytesLo( pCur[m_qwpl+1] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cCur -= cFader; // increase the fade to black
    	    cResult -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
	
			cResult.PackBytes(pCur, cCur);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

== Blit ==

Nesta implementação, as dimensões da janela são verificadas através da função ASSERT (aborta a execução de um programa caso o(s) argumento(s) sejam inválidos). Em seguida, usa uma variável booleana para receber o resultado lógico da função BitBlt (transfere um bloco de bits que corresponde à core de um retângulo de pixels de um ponto da tela para outro) que também é verificada com a função ASSERT.
Desta maneira, ao pausar o BLIT, a imagem parece estar pausada, e ao despausar, uma nova disposição é mostrada. Isso acontece pois os valores de cada ponto continuam sendo calculados e modificados, entretanto, sem serem transferidos para a tela.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,80&chxt=y,x&chbh=a&chs=300x225&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,80,0,80,0,80&chd=t:47,48,49|19,40,32|30,56,44&chdl=Na%C3%AFve|MMX|SSE(2)&chtt=Desempenho+com+a+fun%C3%A7%C3%A3o+BLITT+desativada&fake=name.png

{{{
void CSurface::BlitBits()
{
	ASSERT(m_wndHeight && m_wndWidth);
    BOOL bStat = m_image.BitBlt(m_hDestDC, 0, 0, m_wndWidth, m_wndHeight, 0, m_kDeltaY);

    ASSERT(bStat);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC, // identificador
	_In_ int xDest, // coordenada X do bloco destino
	_In_ int yDest, // coordenada Y do bloco destino
	_In_ int nDestWidth, // largura dos blocos
	_In_ int nDestHeight, // altura dos blocos
	_In_ int xSrc, // coordenada X do bloco fonte
	_In_ int ySrc, // coordenada Y do bloco fonte
	_In_ DWORD dwROP) const throw() // código da operação que define como os blocos fonte e destino são combinados
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, xSrc, ySrc, dwROP );

	ReleaseDC();

	return bResult;
}
}}}

== Swarm ==

=== _Naive_ ===

Nesta implementação, foi definida a classe Swarm e suas funções de manipulação. O construtor (CSwarm::CSwarm()) cria um ponteiro para a imagem de fundo (*CSurface) que inicia com NULL. O destrutor (CSwarm::~CSwarm()) chama a função de destruição (CSwarm::Destroy()) que deleta todos os líderes, todas as lhamas, zera seus contadores e atribue NUL à imagem de fundo. A função de inicialização (CSwarm::Initialize) começa destruindo a imagem atual, verificando as dimensões da nova imagem, limita as bordas da imagem e cria líderes (classe de pontos que se movimentam randomicamente pela imagem deixando rastros brancos) e lhamas (classe de pontos que seguem os líderes e deixam rastros coloridos e trocam de cor quando atingem uma borda da imagem ou quando obtém um novo líder). A função GetLeader(*CSwarm::GetLeader()) retorna o líder a ser seguido pelas lhamas. A função (CSwarm::Tick()) faz um sorteio onde cria um novo líder a partir de outro e deleta o antigo, e em seguida aplica essa funçao para todos outros líderes e lhamas.
Desta maneira, ao pausar o SWARM, o líder e suas lhamas param de se movimentar, fazendo com que os rastros parem de ser criados e desapareçam aos poucos, devido ao efeito do BLUR.

=== MMX ===

-

== Fade In/Out (Transição) ==

<wiki:comment>
Grupo 3
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Esta funcionalidade faz a transição de uma imagem a outra e está implementada apenas com instruções de ponto flutuante (_Naive_).

=== _Naive_ ===

Nesta implementação o valor de `alpha` varia entre 0.0 e 1.0 gradualmente fazendo com que a imagem de origem `cO` se transforme na imagem de destino `cD`.

{{{
            r = (BYTE)((GetRValue(cO)*alpha+GetRValue(cD)*(1.0-alpha)));
            g = (BYTE)((GetGValue(cO)*alpha+GetGValue(cD)*(1.0-alpha)));
            b = (BYTE)((GetBValue(cO)*alpha+GetBValue(cD)*(1.0-alpha)));
}}}

=== MMX ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CMMXUnsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

=== SSE(n) ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CSSE2Unsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

== Grayscale (Tons de cinza) ==

<wiki:comment>
Grupo 4
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Este filtro transforma a imagem atual em uma imagem com tons de cinza.

=== _Naive_ ===

Para esta implementação os valores R, G, B são atualizados com uma média simples entre estes valores.

{{{
void CSurface::GrayScale()
{
	COLORREF cCur;		//declara um dword
	BYTE r, g, b;		//variáveis tipo byte que receberão os valores RGB

	//realiza um loop dentro do outro para percorrer a tela inteira
	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);		//pega um pixel da tela da posição [i,j]
			r = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);	//realiza média entre valores RGB e atualiza valor R
			g = r;	//atualiza valor de G com média ja calculada em R
			b = r;	//atualiza valor de B com média ja calculada em R
			PointColor(j,i,RGB(b,g,r));		//reescreve na tela o pixel do valores RGB modificados na posição [i,j]
		}
	}
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 10 fps. 

=== MMX ===

Esta implementação utilizou inline assembly para acessar os registradores de 64 bits mmx. A ideia do código é simples: através de uma máscara que seleciona um byte por vez, os valores RGB são extraídos e uma média simples é realizada entre eles. Com isso o valor do pixel atual é modificado utilizando a média calculada anteriormente.  
 
{{{
void CMMXSurface32Intrinsic::GrayScale()
{
    int height = GetVisibleHeight()*2;	//altura multiplicada por 2 pois são pixels de 32 bits em variáveis de64 bits (2x maior)
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	// cada pixel tem 32bits, 1byte para cada canal de cor: alfa, red, green, blue

	// Variaveis do tipo unsigned long long, de 64 bits
	ULONGLONG mascara = 0xFF;	//seleciona um byte de alguma variável (utilizada para pegar valores individuais de RGB)	
	ULONGLONG pixel;	//recebe os valores referentes a um ponto da tela
	ULONGLONG next;		//recebe os valores do próximo ponto a partir de pixel 
	
	pixel = *(ULONGLONG *)pCur;	//faz um casting 64 bits dos dados do ponto atual na variável pixel
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next = *(ULONGLONG *)(pCur+1);	//próximo ponto recebe o ponteiro que aponta para um ponto na tela + 1
			
			//utilização dos registradores mmx 64 bits com inline assembly 
			__asm{
				movq mm0, pixel		//registrador mm0 reebe o valor do pixel atual
				pand mm0, mascara	//valor de mm0 recebe uma mascara para selecionar seu 1 byte menos significativo (B)
				movq mm1, mm0		//guarda o valor calculado acima em mm1
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 8		//realiza um shift lógico para a direita para pegar o próximo byte
				pand mm0, mascara	//utilizar mascara para isolar um byte (G)
				paddd mm1, mm0		//soma o valor calculado anteriormente em mm1 (B+G)
				movq mm0, pixel		//recarrega o valor do pixel em mm0
				psrlq mm0, 16		//realiza um shift lógico para direita para pegar o 3 byte
				pand mm0, mascara	//utiliza mascara para isolar um byte (R)
				paddd mm1,mm0		//soma o valor calculado acima em mm1 (B+G+R)
				movq pixel, mm1		//move para a variável pixel a soma dos valores RGB calculados nos registradores mmx
			}

			pixel /= 3;				//realiza media dos valores RGB ((R+G+B)/3)

			__asm{
				movq mm0, pixel		//mm0 recebe a media dos valores RGB
				movq mm1, mm0		//copia mm0 em mm1
				psllq mm0, 8		//realiza um shift lógico para esquerda em 1 byte
				paddd mm1, mm0		//soma a (media<<8) em mm1 
				psllq mm0, 8		//novamente um shift para esquerda em 1 byte
				paddd mm1, mm0		//soma a (media<<16) em mm1
				movq pixel, mm1		//mm1 agora possui os valores médios RGB (GrayScale), então salva isso em pixel
			}

			*(ULONGLONG *)pCur = pixel;		//joga o resultado no ponto apontado da tela
			pixel = next;					//recebe o próximo pixel a ser processado
			pCur++;							//avança o ponteiro sobre a tela
		} while (--width > 0);
	} while (--height > 0);
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 19 fps, o que mostra um bom ganho de desempenho comparando com a versão Naive, que consegue fazer somente 10 fps.

=== SSE(n) ===

Esta implementação utilizou inline assembly para acessar os registradores de 128 bits sse. A lógica do código é a mesma da implementação MMX, a diferença é que agora dois pixels são processados de uma vez só em cada passagem do loop, gerando ganho de desempenho.

{{{
void CSSE2Surface32Intrinsic::GrayScale()
{
    int height = GetVisibleHeight()*2;				//aumenta a altura em 2 pois são processados 2 pixels de 32-bits de uma só vez em variáveis de 128 bits	
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);	//ponteiro para posição atual da tela
	
	ULONGLONG mascara = 0xFF;						//máscara para selecionar um byte por vez
	ULONGLONG pixel1, pixel2;						//variaveis de 64 bits que receberão valores de dois pixels consecutivos
	ULONGLONG next1, next2;							//variéveis que guardam a próximas posições de pixel1 e pixel2
	ULONGLONG media1, media2;						//medias RGB de pixel1 e pixel2 respectivamente

	pixel1 = *(ULONGLONG *) pCur;					//pixel1 recebe pixel que está sendo apontado no inicio (0,0) 
	pixel2 = *(ULONGLONG *) (pCur+1);				//pixel2 recebe pixel consecutivo (0,1)
	
	//loops para percorrer toda a tela
	do {
		int width = m_width;
		do {
			
			next1 = *(ULONGLONG *) (pCur+2);		//guarda próximo valor para pixel1	
			next2 = *(ULONGLONG *) (pCur+3);		//guarda próximo valor para pixel2	
			
			__asm{
				movq xmm0, pixel1					//move pixel1 para os 64 bits menos significativos de xmm0 (128 bits)
				movhpd xmm0, pixel2					//move pixel2 para os 64 bits mais significativos de xmm0
				movq xmm1, mascara					//xmm1 fará o papel de seletor de bytes especificos de xmm0
				pand xmm1,xmm0						//seleciona primeiro byte de xmm0 e guarda em xmm1
				movq xmm2,xmm1						//xmm2 receberá a soma dos bytes selecionados
				movq xmm1,mascara					
				psrldq xmm0,1						//desloca em 1 para direita xmm0 (como são registradores 128 bits, na verdade ocorre um deslocamento de 2 unidades)
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media1,xmm2					//recebe a soma dos valores RGB de pixel1 (parte menos significativa de xmm0)
				movq xmm1,mascara
				psrldq xmm0,2						//desloca em 2 para direita xmm0, para selecionar agora sua metade mais significativa (pixel2)
				pand xmm1,xmm0
				movq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq xmm1,mascara
				psrldq xmm0,1
				pand xmm1,xmm0
				paddq xmm2,xmm1
				movq media2,xmm2					//salva a soma dos valores RGB de pixel2 em media2
			}

			media1 /= 3;							//realiza média efetiva dos pixels
			media2 /= 3;

			__asm{
				movq xmm0,media1					//xmm0 receberá as medias byte a byte 
				movq xmm1,xmm0
				pslldq xmm0,1
				paddq xmm0,xmm1
				pslldq xmm0,1
				paddq xmm0,xmm1
				movq pixel1,xmm0					//atualiza o valor de pixel1, com xmm0 que contém a média nos seus valores RGB 
				movq xmm0,media2
				movq xmm1,xmm0
				pslldq xmm0,1
				paddq xmm0,xmm1
				pslldq xmm0,1
				paddq xmm0,xmm1
				movq pixel2,xmm0					//atualiza o valor de pixel2, com xmm0 que contém a média nos seus valores RGB
			}

			*(ULONGLONG *)pCur = pixel1;			//joga o valor calculado de pixel1 de volta na tela
			*(ULONGLONG *)(pCur+1) = pixel2;		//joga o valor calculado de pixel2 de volta na tela
			pixel1 = next1;							//pixel1 recebe o próximo pixel 
			pixel2 = next2;							//pixel2 recebe o próximo pixel
			pCur += 2;								//aumenta o ponteiro da tela em 2 (calcula 2 pixels por vez)
		} while (--width > 0);
	} while (--height > 0);
}
}}}

Para uma imagem estática de 1498x935 esta implementação consegue calcular 23 fps, demonstrando que o processamento de 2 pixels por vez consegue ainda ganhar no desempenho em relação a implementação MMX e mais que dobrar a quantidade de fps calculados em relação a versão Naive.



== Sobel (Detecção de bordas) ==

<wiki:comment>
Grupo 5
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

O mecanismo de detecção de borda Sobel é elaborado com a finaliadde de encontrar os pixels onde há uma mudança no nível de intensidade, sendo está mudança uma característica relevante de uma borda em uma imagem. Assim quando esses pixel estão próximos podem ser destacados formando uma borda.
A sua implementação consiste no cálculo do gradiente da imagem. Esse cálculo é feito definindo máscaras que caracterizam a variação de intensidade presente nas bordas de imagens, e em seguida fazer a convolução da imagem pela máscara.

=== _Naive_ ===

{{{

//Máscara do sobel
//X
GXS[0][0] = -1; GXS[0][1] = 0; GXS[0][2] = 1;
GXS[1][0] = -2; GXS[1][1] = 0; GXS[1][2] = 2;
GXS[2][0] = -1; GXS[2][1] = 0; GXS[2][2] = 1;
//Y
GYS[0][0] = -1; GYS[0][1] = -2; GYS[0][2] = -1;
GYS[1][0] = 0; GYS[1][1] = 0; GYS[1][2] = 0;
GYS[2][0] = 1; GYS[2][1] = 2; GYS[2][2] = 1;

void CSurface::Sobel()
{
    COLORREF cCur;

    sumX = 0;
    sumY = 0;
    SUM = 0;

    //Percorre toda imagem
    for (y = 0; y < m_wndHeight; y++) {
        for (x = 0; x <m_wndWidth; x++) {
	    sumX = 0;
	    sumY = 0;

	    //Se for boada, atribui o valor 0(preto)
	    if((y==0) || (y == (m_wndHeight - 1)) || (x==0) || (x == (m_wndWidth - 1)))
	        SUM = 0;
		else{
		    for(I=-1; I<=1; I++){
		        for(J=-1; J<=1; J++){
		            piX = J + x;
			    piY = I + y;

			    //Pega o valor da imagem corrente
			    cCur = PointColor(piX,piY);

			    r = GetRValue(cCur);
			    g = GetGValue(cCur);
			    b = GetBValue(cCur);

			    NC = (r+g+b)/3;

			    sumX = sumX + (NC) * GXS[J+1][I+1];
			    sumY = sumY + (NC) * GYS[J+1][I+1];
			}
		    }

		    SUM = abs(sumX) + abs(sumY);
		}

		if(SUM>255) SUM=255;
		if(SUM<0) SUM=0;
		newPixel = ((unsigned char)(SUM));
			
		PointColorT(x,y,RGB(newPixel,newPixel,newPixel));
	    }
	}

    //Quando terminar, copia o resultado para a imagem corrente
    Copy(t_image);
}
}}}

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Mandelbrot ==

<wiki:comment>
Grupo 6
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

----

= Capture =

----

= GPU (OpenCL) =

<wiki:comment>
Grupo 7
Implementar e descrever a função InvertImage nas versões Normal, MMX e SSE
</wiki:comment>