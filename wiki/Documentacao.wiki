#summary Documentação das funcionalidades implementadas no programa.
#labels Phase-Implementation,Phase-Design

= Introdução =

O objetivo deste projeto é disponibilizar implementações que possam ser usadas para comparar o desempenho das instruções de multimídia nas arquiteturas Intel(r).

O código original do programa pode ser baixado em [http://msdn.microsoft.com/en-us/library/0aws1s9k(v=vs.80).aspx]

----

= Versões 16, 24 e 32 bits =

<wiki:comment>
Grupo 1
Descrever as diferenças de desempenho e em quais implementações se aplicam. (Normal, MMX e SSE)
</wiki:comment>

A análise de desempenho entre as versões de 16, 24 e 32 bits é feita a partir dos códigos-fonte das implementações: Naive, MMX e SSE2.

Primeiramente é importante conhecer a parte teórica referente a cada conjunto de instruções. 

<b>Naive</b>

Trata-se da implementação básica, pois não utiliza um conjunto de instruções específicos para otimização.

<b>MMX</b>

Conjunto de instruções criado pela Intel para aplicações multimídia com a finalidade de aumentar performance. Ele é voltado para a melhora na execução de operações em grandes vetores de dados.
Implementa o modelo de execução SIMD (Single Instruction Multiple Data) pois assim quando se trabalha com arquivos multimídia são utilizados grandes vetores de dados de modo a agilizar a leitura e processamento devido aos registradores de 64 bits.

<b>SSE2</b>

Trata-se do sucessor do MMX e permite aumentar performance em operações de ponto flutuante. Extende as operações do MMX para registradores XMM (64 bits) o que permite ao programador evitar os registradores MM, que não possuem suporte específico para operações de ponto flutuante, fornecendo maior precisão.

=== Estudando o desempenho ===

O gráfico a seguir mostra os resultados de testes feitos usando o código fornecido no repositório para os três conjuntos de instruções citados.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,105&chxs=0,676767,11.5,0,lt,676767&chxt=y,x&chbh=14,5,10&chs=300x225&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,100,0,100,0,105&chd=t:87,84,89|42,77,70|66,105,88&chdl=Naive|MMX|SSE2&chtt=Gr%C3%A1fico+de+Desempenho+%28FPS%29.jpg

|| *Versão* || *Naïve* || *MMX* || *SSE2* ||
|| *16 bits* || 87 || 42 || 66 ||
|| *24 bits* || 84 || 77 || 105 ||
|| *32 bits* || 89 || 70 || 88 ||

Obs1: Valores do eixo y em frames per second (fps) e testados em resolução 320x240.

Obs2: Valores possuem certa variância devido ao fato do computador estar executando outras tarefas.

<a continuar>


----

= Implementações =

<wiki:comment>
Grupo 2
Descrever Blur, Blit e Swarm nas três versões (Normal, MMX e SSE).
</wiki:comment>

== Blur/Smooth (Borrar) ==

Este efeito é obtido por meio da média do pixel com seus vizinhos, porém o pixel central tem peso maior.

=== _Naive_ ===

Nesta implementação o valor de cada pixel é multiplicado por 4 (`GetRValue(cCur) << 2`), somado aos 4 vizinhos e dividido por 8.

{{{
void CSurface::BlurBits()
{
    COLORREF cLeft = 0, cCur = PointColor(0,0), cRight, cUp, cDown;
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        cLeft = 0;
        for (int j = 0; j < m_wndWidth; j++) {
            cRight = PointColor(j+1, i);
            cUp = PointColor(j, i-1);
            cDown = PointColor(j, i+1);
            r = (BYTE)(((int)(GetRValue(cCur) << 2) + GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) >> 3);
            g = (BYTE)(((int)(GetGValue(cCur) << 2) + GetGValue(cLeft) + GetGValue(cRight) + GetGValue(cUp) + GetGValue(cDown)) >> 3);
            b = (BYTE)(((int)(GetBValue(cCur) << 2) + GetBValue(cLeft) + GetBValue(cRight) + GetBValue(cUp) + GetBValue(cDown)) >> 3);
            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
            cLeft = cCur;
            cCur = cRight;
        }
    }
}
}}}

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Blit ==

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Swarm ==

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Fade In/Out (Transição) ==

<wiki:comment>
Grupo 3
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Esta funcionalidade faz a transição de uma imagem a outra e está implementada apenas com instruções de ponto flutuante (_Naive_).

=== _Naive_ ===

Nesta implementação o valor de `alpha` varia entre 0.0 e 1.0 gradualmente fazendo com que a imagem de origem `cO` se transforme na imagem de destino `cD`.

{{{
            r = (BYTE)((GetRValue(cO)*alpha+GetRValue(cD)*(1.0-alpha)));
            g = (BYTE)((GetGValue(cO)*alpha+GetGValue(cD)*(1.0-alpha)));
            b = (BYTE)((GetBValue(cO)*alpha+GetBValue(cD)*(1.0-alpha)));
}}}

=== MMX ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CMMXUnsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

=== SSE(n) ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CSSE2Unsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

== Grayscale (Tons de cinza) ==

<wiki:comment>
Grupo 4
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Este filtro transforma a imagem atual em uma imagem com tons de cinza.

=== _Naive_ ===

Para esta implementação os valores R, G, B são atualizados com uma média simples entre estes valores.

{{{
void CSurface::GrayScale()
{
	COLORREF cCur;
	BYTE r, g, b;

	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);
			r = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			g = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			b = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);			
			PointColor(j,i,RGB(b,g,r));
		}
	}
}
}}}


=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

TODO: descrever o algoritmo e suas implementações

== Sobel (Detecção de bordas) ==

<wiki:comment>
Grupo 5
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

TODO: descrever o algoritmo e suas implementações

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Mandelbrot ==

<wiki:comment>
Grupo 6
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

----

= Capture =

----

= GPU (OpenCL) =

<wiki:comment>
Grupo 7
Implementar e descrever a função InvertImage nas versões Normal, MMX e SSE
</wiki:comment>