#summary Documentação das funcionalidades implementadas no programa.
#labels Phase-Implementation,Phase-Design

= Introdução =

O objetivo deste projeto é disponibilizar implementações que possam ser usadas para comparar o desempenho das instruções de multimídia nas arquiteturas Intel(r).

O código original do programa pode ser baixado em [http://msdn.microsoft.com/en-us/library/0aws1s9k(v=vs.80).aspx]

----

= Versões 16, 24 e 32 bits =

<wiki:comment>
Grupo 1
Descrever as diferenças de desempenho e em quais implementações se aplicam. (Normal, MMX e SSE)
</wiki:comment>

A análise de desempenho entre as versões de 16, 24 e 32 bits é feita a partir dos códigos-fonte das implementações: Naive, MMX e SSE2.

Primeiramente é importante conhecer a parte teórica referente a cada conjunto de instruções. 

<b>Naive</b>

Trata-se da implementação básica, pois não utiliza um conjunto de instruções específicos para otimização.

<b>MMX</b>

Conjunto de instruções criado pela Intel para aplicações multimídia com a finalidade de aumentar performance. Ele é voltado para a melhora na execução de operações em grandes vetores de dados.
Implementa o modelo de execução SIMD (Single Instruction Multiple Data) pois assim quando se trabalha com arquivos multimídia são utilizados grandes vetores de dados de modo a agilizar a leitura e processamento devido aos registradores de 64 bits.

<b>SSE2</b>

Trata-se do sucessor do MMX e permite aumentar performance em operações de ponto flutuante. Extende as operações do MMX para registradores XMM (64 bits) o que permite ao programador evitar os registradores MM, que não possuem suporte específico para operações de ponto flutuante, fornecendo maior precisão.

===Análise de performance===

Os programas em MMX e SSE2 usam recursos para aumentar a performance das operações e movimentações de informações: utilizam os registradores estendidos de 64 bits para executar várias instruções em um grande vetor de dados em um tempo reduzido, em comparação com os registradores usuais da linguagem. No caso do programa em questão, os registradores são usados para obtenção de vários pixels na tela de uma só vez, e baseado nessas localizações, fazer as operações necessárias em todos estes lugares.

*MMX-16*

O código MMX para cores com 16 bits de profundidade consiste em:

1.Passar o endereço do pixel da posição corrente para uma variável pCur, no formato ULONGLONG(64bits).

2.Por manipulação deste ponteiro, obter as posições dos pixels ao redor (cUp, cDown, cLeft, cRight, cCur) e compará-los a uma máscara previamente inicializada para editar os bits das posições relevantes à cor.

Após isto, as cores dos pixels ao redor são usadas na modificação desejada (no caso, estamos analisando o efeito Blur). A distribuição das cores é feita entre os pixels, e a próxima posição desejada é calculada. A operação é repetida.

*MMX-24*

O código MMX para cores com 24 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato DWORD. 

2.Cria-se uma variável de 64 bits cFader, que será usada nas operações para a modificação dos valores dos pixels. Isto é feito a partir de uma operação chamada UnpackBytesLo de forma simplificada ele pega a dword que pCur aponta e faz um tipo de concatenação com uma dword cheia de zeros da seguinte forma: suponha que pCur aponta pra dword ff0a0b0c. Neste caso, 0a0b0c representa o RGB do pixel e ff sua transparência. Quando se chama cCur.UnpackBytesLo ( *pCur ), ele empacota na variável cCur uma QWORD 00ff000a000b000c, ou seja, ele faz uma "mescla" byte a byte do vetor passado como referência com um vetor de zeros. Então, as operações feitas neste registrador são feitas duas vezes mais (como se fossem feitas em um bit válido e um bit que sempre está em zero). Isto rende uma perda de performance.

3.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes são "desempacotados" e usados nas operações de modificação de cores. Calcula-se o próximo pixel e repete-se o passo 3.

*MMX-32*

O código MMX para cores com 32 bits de profundidade consiste em:

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG. 

2.Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes(contando com os pixels da diagonal direita superior, diagonal direita inferior e o segundo pixel da direita) são "desempacotados" e usados nas operações de modificação de cores. 

3.Depois das modificações das cores, os pixels são reempacotados em uma variável de 64 bits. Repetem-se os passos 2 e 3.

_Observações sobre MMX:_

Todas as operações em MMX envolvem o uso de instruções de empacotamento de bytes. Estas instruções tem alguns pontos onde a performance do sistema é afetada por operações desnecessárias nos pixels. Por exemplo, o PUNPCKLBW, instrução MMX para o desempacotamento de uma DWORD, gera bits zerados que não contribuem para o programa, e que entram em loops e operações supérfluas.

Podemos ver pela performance dos códigos em MMX que estes não são eficientes neste programa, sendo mais lentos que a implementação Naive e a SSE2.

*SSE2-16*

Este código processa cada pixel em uma WORD, carregando poucos dados em cada uma de suas execuções, fazendo com que sua performance seja diminuída.

1.Passar o endereço da posição corrente para uma variável pCur, no formato __m128i.

2.Por meio de manipulações neste ponteiro, podemos obter as posições dos pixels adjacentes (cDownBase, etc). Estas posições são passadas por uma máscara: cada parte de 16 bits de um pixel tem os últimos cinco bits reservados para as informações de cor (cDown, cUp, etc).

3.Após isto, ele executa as operações matemáticas para no pixel corrente e nos dois próximos pixels à direita. Avança o ponteiro e repetem-se os dois passos.

*SSE2-24*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Com base neste ponteiro corrente, desempacota-o para obter os pixels adjacentes, e executa as operações matemáticas nas cores da posição corrente.

3.Avança o ponteiro, e re-executa o passo 2.

4.O resultado é empacotado na posição do ponteiro corrente. Avança o ponteiro, e recomeça o processo do passo 2.

*SSE2-32*

1.Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG.

2.Fazemos o casting deste ponteiro para o tipo RGBQUAD, que é formado por: três Bytes que fazem referência às cores vermelha, verde e azul, e um Byte reservado. O próximo ponteiro é definido aqui também.

3.Fazemos as operações matemáticas para definir a cor do pixel corrente, e do próximo. O cFader entra logo depois, aumentando ou diminuindo o tom da cor.

4.Empacotamos a cor do pixel corrente no seu ponteiro, e avançamos o pCur. Recomeça o processo a partir do 2.

=== Estudando o desempenho ===

Numa primeira análise observamos as linhas de código (LOC) das implementações MMX e SSE2. Porém sabemos que trata-se apenas de um indicador de performance e não nos dá uma ideia precisa das reais diferenças entre as implementações. As linhas de código do Naive não foram consideradas, pois não apresentam diferença nenhuma.

|| *Versão* || *MMX* || *SSE2* ||
|| *16 bits*|| 538 LOC  || 533 LOC ||
|| *24 bits*|| 204 LOC || 301 LOC || 
|| *32 bits*|| 283 LOC || 311 LOC ||


Já o gráfico a seguir mostra os resultados de testes feitos usando o código fornecido no repositório para os três conjuntos de instruções citados.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,105&chxs=0,676767,11.5,0,lt,676767&chxt=y,x&chbh=a,5,10&chs=600x300&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,100,0,100,0,105&chd=t:87,84,89|42,77,70|66,105,88&chdl=Naive|MMX|SSE2&chtt=Gr%C3%A1fico+de+Desempenho+(FPS)&fake=name.png

|| *Versão* || *Naive* || *MMX* || *SSE2* ||
|| *16 bits* || 87 || 42 || 66 ||
|| *24 bits* || 84 || 77 || 105 ||
|| *32 bits* || 89 || 70 || 88 ||

Obs1: Valores do eixo y em frames per second (fps) e testados em resolução 320x240.

Obs2: Valores possuem certa variância devido ao fato do computador estar executando outras tarefas.



----

= Implementações =

<wiki:comment>
Grupo 2
Descrever Blur, Blit e Swarm nas três versões (Normal, MMX e SSE).
</wiki:comment>

== Blur/Smooth (Borrar) ==

Este efeito é obtido por meio da média do pixel com seus vizinhos, porém o pixel central tem peso maior, deixando um rastro que ao passar do tempo (dos cálculos da média) vai desaparecendo.
Desta maneira, ao pausar o BLUR, as Llamas do SWARM tendem a acelerar instantaneamente, pois é pausado todos os cálculos de desempacotamento, leitura, e operações matematicas, permitindo com que a capacidade de processamento possa ser utilizada por completa na movimentação das Llamas.

=== _Naive_ ===

Nesta implementação o valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) e dividido por 8 (>> 3).

{{{
void CSurface::BlurBits()
{
    COLORREF cLeft = 0, cCur = PointColor(0,0), cRight, cUp, cDown;
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        cLeft = 0;
        for (int j = 0; j < m_wndWidth; j++) {
            cRight = PointColor(j+1, i);
            cUp = PointColor(j, i-1);
            cDown = PointColor(j, i+1);
            r = (BYTE)(((int)(GetRValue(cCur) << 2) + GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) >> 3);
            g = (BYTE)(((int)(GetGValue(cCur) << 2) + GetGValue(cLeft) + GetGValue(cRight) + GetGValue(cUp) + GetGValue(cDown)) >> 3);
            b = (BYTE)(((int)(GetBValue(cCur) << 2) + GetBValue(cLeft) + GetBValue(cRight) + GetBValue(cUp) + GetBValue(cDown)) >> 3);
            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
            cLeft = cCur;
            cCur = cRight;
        }
    }
}
}}}

=== MMX ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CMMXSurface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);

	CMMX cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CMMX cUp, cDown, cCur, cLeft, cRight;
	CMMX cDest;
	CMMX cMask(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase = *(ULONGLONG*)(pwCur-1);
			cCurBase = pCur[0];
			cRightBase = *(ULONGLONG*)(pwCur+1);
			cUpBase = pCur[-m_qwpl];
			cDownBase = pCur[+m_qwpl];

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			*pCur++ = cDest;
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores MMX sã0 de 64 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar MMX na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight;
	CMMX cLeft;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(DWORD *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(DWORD *)(bpCur+1) );
			*pCur++ = cUp.PackBytes();
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores MMX são de 64 bits, os dados podem ser alinhados, sendo possível manipular 2 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atrobuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown) .O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CMMXSurface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    DWORD *pCur  = (DWORD*)GetPixelAddress(0,0);

	CMMX cFader;
	CMMX cRight, cRightRight;
	CMMX cDownRight;
	CMMX cLeft;
	CMMX cUpRight;
	CMMX cUp, cDown, cCur;

	cFader.UnpackBytesLo( 0x01010101 );
	cLeft.Clear();
	cCur.UnpackBytesLo( *pCur );

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			cRight.UnpackBytesLo( pCur[1] );
			cRightRight.UnpackBytesLo( pCur[2] );
			cUp.UnpackBytesLo( pCur[-m_dwpl] );
			cUpRight.UnpackBytesLo( pCur[-m_dwpl+1] );
			cDown.UnpackBytesLo( pCur[m_dwpl] );
			cDownRight.UnpackBytesLo( pCur[m_dwpl+1] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cUp = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cDown = (cDownRight+cUpRight+cCur+cRightRight+(cRight<<2))>>3;

#if defined(TRIPPY)
			cUp += cFader; // increase the fade to white
			cDown += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cUp -= cFader; // increase the fade to black
    	    cDown -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
			cCur = cRightRight;
	
			*(ULONGLONG *)pCur = cUp.PackBytes(cDown);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

=== SSE(n) ===

16 bits: Nesta implementação, como o buffer é de 16 bits e os registradores MMX são de 128 bits, os dados podem ser alinhados, sendo possível manipular 8 pixels, acelerando o processo de desempacotamento e de leitura de dados. Os valores dos vizinhos são calculados com um valor base e uma máscara que contém que possuem que ativa os 5 primeiros bits a cada 16, e são realizadas 3 iterações para calcular a média do pixel com base nos valores vizinhos (esquerdo, direito, inferior e superior). Essa etapa é efetuada em cada pixel.

{{{
void CSSE2Surface16Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    __m128i *pCur  = (__m128i *)GetPixelAddress(0,0);

	CSSE2 cUpBase, cDownBase, cCurBase, cLeftBase, cRightBase;
	CSSE2 cUp, cDown, cCur, cLeft, cRight;
	CSSE2 cDest;
	CSSE2 cMask;
	cMask.Fill(0x001f001f001f001fu); // colorspace mask - 5 bits per color

	do {
		int width = m_width;
		do {
			// Load pixels and do the mmx unpack
			// Note: pwCur is used to do non-aligned
			// data reads - which is not normally recommended.
			// on X86, it is faster than loading aligned and
			// shift-oring.
			WORD *pwCur = (WORD *)pCur;
			cLeftBase.LoadU(pwCur-1);
			cCurBase.Load(pCur);
			cRightBase.LoadU(pwCur+1);
			cUpBase.Load(pCur-m_qqwpl);
			cDownBase.Load(pCur+m_qqwpl);

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cDest = ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = cLeftBase & cMask;
			cCur = cCurBase & cMask;
			cRight = cRightBase & cMask;
			cUp = cUpBase & cMask;
			cDown = cDownBase & cMask;

			// Actual math for next color space
			cDest |= cMask & ((cDown+cUp+cLeft+cRight+(cCur<<2))>>3);
			cMask <<= 5;

			cLeft = (cLeftBase & cMask) >> 3;
			cCur = (cCurBase & cMask) >> 3;
			cRight = (cRightBase & cMask) >> 3;
			cUp = (cUpBase & cMask) >> 3;
			cDown = (cDownBase & cMask) >> 3;

			// Actual math for next color space
			cDest |= cMask & (cDown+cUp+cLeft+cRight+(cCur<<2));
			cDest.Store(pCur++);
			cMask >>= 10;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

24 bits: Nesta implementação , como o buffer é de 24 bits e os registradores MMX são de 128 bits, os dados não podem ser corretamente alinhados, não havendo grande vantagem em utilizar MMX na versão 24 bits, em comparação às outras. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp). O CMMX cFader é usado para acelerar o processo de clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface24Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG*)GetPixelAddress(0,0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		do {
			BYTE *bpCur = (BYTE *)pCur;
			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( pCur[0] );
			// treating non-aligned data as dwords isn't generally a good idea
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Sum the 4 around and double the middle
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			pCur++;
			bpCur = (BYTE *)pCur;
			cCur.UnpackBytesLo( pCur[0] );
			cRight.UnpackBytesLo( *(ULONGLONG *)(bpCur+3) );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
			cCur -= cFader; // increase the fade to white
			cResult -= cFader; // increase the fade to white
#endif
			// Reset the left before we write anything out.
			// treating non-aligned data as dwords isn't generally a good idea
			cLeft.UnpackBytesLo( *(ULONGLONG *)(bpCur+5) );
			cResult.PackBytes(pCur-1, cCur);
			pCur++;
		} while (--width > 0);
		pCur += m_delta;
	} while (--height > 0);
}
}}}

32 bits: Nesta implementação, como o buffer é de 32 bits e os registradores MMX são 128 bits, os dados podem ser alinhados, sendo possível manipular 4 pixels, acelerando o processo de desempacotamento e de leitura de dados. O valor de cada pixel é multiplicado por 4 (GetRValue(cCur) << 2), somado aos 4 vizinhos (esquerdo, direito, inferior e superior) (cDown+cUp+cLeft+cRight), dividido por 8 (>> 3) e atribuído ao pixel superior (cUp), e o pixel seguinte também é calculado, mustiplicando-o por 4 (), soamando aos vizinhos mais distantes (cDownRight+cUpRight+cCur+cRightRight), dividido por 8 (>> 3) e atribuído ao pixel inferior (cDown).O CMMX cFader é usado para acelerar o processo de  clareamento (com TRIPPY: cUp += cFader) ou escurecimento (com FAST_FADE: cUp -= cFader).

{{{
void CSSE2Surface32Intrinsic::BlurBits()
{
    int height = GetVisibleHeight();
    ULONGLONG *pCur  = (ULONGLONG *)GetPixelAddress(0,0);
	ASSERT((DWORD_PTR(pCur) & 0xF) == 0);

	CSSE2 cFader;
	CSSE2 cRight, cLeft;
	CSSE2 cUp, cDown, cCur;
	CSSE2 cResult;

	cFader.UnpackBytesLo( 0x0101010101010101u );
	cLeft.Clear();

	do {
		int width = m_width;
		ASSERT((DWORD_PTR(pCur) & 0xF) == 0);
		do {
			RGBQUAD *pdwCur = (RGBQUAD*)pCur;
			ULONGLONG *pNext = (ULONGLONG*)(pdwCur+1);

			// Load pixels and do the mmx unpack
			cCur.UnpackBytesLo( *pCur );
			cRight.UnpackBytesLo( *pNext );
			cUp.UnpackBytesLo( pCur[-m_qwpl] );
			cDown.UnpackBytesLo( pCur[m_qwpl] );

			// Actual math. Don't step on current, or right.
			// Sum the 4 around and double the middle
			
			// Do current pixel in this line
			cResult = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

			// Do next pixel
			cLeft = cRight; 		// Slide left!
			cCur.UnpackBytesLo( pCur[1] );
			cRight.UnpackBytesLo( pNext[1] );
			cUp.UnpackBytesLo( pCur[-m_qwpl+1] );
			cDown.UnpackBytesLo( pCur[m_qwpl+1] );
			cCur = (cDown+cUp+cLeft+cRight+(cCur<<2))>>3;

#if defined(TRIPPY)
			cCur += cFader; // increase the fade to white
			cResult += cFader; // increase the fade to white
#elif defined (FAST_FADE)
    	    cCur -= cFader; // increase the fade to black
    	    cResult -= cFader; // increase the fade to black
#endif
			cLeft = cRight; 		// Slide left!
	
			cResult.PackBytes(pCur, cCur);
			pCur += 2;
		} while (--width > 0);
	} while (--height > 0);
}
}}}

== Blit ==

Nesta implementação, as dimensões da janela são verificadas através da função ASSERT (aborta a execução de um programa caso o(s) argumento(s) sejam inválidos). Em seguida, usa uma variável booleana para receber o resultado lógico da função BitBlt (transfere um bloco de bits que corresponde à core de um retângulo de pixels de um ponto da tela para outro) que também é verificada com a função ASSERT.
Desta maneira, ao pausar o BLIT, a imagem parece estar pausada, e ao despausar, uma nova disposição é mostrada. Isso acontece pois os valores de cada ponto continuam sendo calculados e modificados, entretanto, sem serem transferidos para a tela.

{{{
void CSurface::BlitBits()
{
	ASSERT(m_wndHeight && m_wndWidth);
    BOOL bStat = m_image.BitBlt(m_hDestDC, 0, 0, m_wndWidth, m_wndHeight, 0, m_kDeltaY);

    ASSERT(bStat);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ DWORD dwROP) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, xSrc, ySrc, dwROP );

	ReleaseDC();

	return bResult;
}
}}}

== Swarm ==

=== _Naive_ ===

Nesta implementação, foi definida a classe Swarm e suas funções de manipulação. O construtor (CSwarm::CSwarm()) cria um ponteiro para a imagem de fundo (*CSurface) que inicia com NULL. O destrutor (CSwarm::~CSwarm()) chama a função de destruição (CSwarm::Destroy()) que deleta todos os líderes, todas as lhamas, zera seus contadores e atribue NUL à imagem de fundo. A função de inicialização (CSwarm::Initialize) começa destruindo a imagem atual, verificando as dimensões da nova imagem, limita as bordas da imagem e cria líderes (classe de pontos que se movimentam randomicamente pela imagem deixando rastros brancos) e lhamas (classe de pontos que seguem os líderes e deixam rastros coloridos e trocam de cor quando atingem uma borda da imagem ou quando obtém um novo líder). A função GetLeader(*CSwarm::GetLeader()) retorna o líder a ser seguido pelas lhamas. A função (CSwarm::Tick()) faz um sorteio onde cria um novo líder a partir de outro e deleta o antigo, e em seguida aplica essa funçao para todos outros líderes e lhamas.
Desta maneira, ao pausar o SWARM, o líder e suas lhamas param de se movimentar, fazendo com que os rastros parem de ser criados e desapareçam aos poucos, devido ao efeito do BLUR.

=== MMX ===

-

== Fade In/Out (Transição) ==

<wiki:comment>
Grupo 3
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Esta funcionalidade faz a transição de uma imagem a outra e está implementada apenas com instruções de ponto flutuante (_Naive_).

=== _Naive_ ===

Nesta implementação o valor de `alpha` varia entre 0.0 e 1.0 gradualmente fazendo com que a imagem de origem `cO` se transforme na imagem de destino `cD`.

{{{
            r = (BYTE)((GetRValue(cO)*alpha+GetRValue(cD)*(1.0-alpha)));
            g = (BYTE)((GetGValue(cO)*alpha+GetGValue(cD)*(1.0-alpha)));
            b = (BYTE)((GetBValue(cO)*alpha+GetBValue(cD)*(1.0-alpha)));
}}}

=== MMX ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CMMXUnsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

=== SSE(n) ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CSSE2Unsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

== Grayscale (Tons de cinza) ==

<wiki:comment>
Grupo 4
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Este filtro transforma a imagem atual em uma imagem com tons de cinza.

=== _Naive_ ===

Para esta implementação os valores R, G, B são atualizados com uma média simples entre estes valores.

{{{
void CSurface::GrayScale()
{
	COLORREF cCur;
	BYTE r, g, b;

	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);
			r = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			g = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			b = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);			
			PointColor(j,i,RGB(b,g,r));
		}
	}
}
}}}


=== MMX ===

Esta implementação utiliza o empacotamento de dados mmx através do método UnpackBytesLo. Para retirar os valores RGB destes dados empacotados foi utilizada um máscara que pega 1 byte por vez. Com isso isolamos os valores RGB para realizar uma média e com esta média formamos um novo dado empacotado, gerando assim uma imagem em tons de cinza. Como este empacotamento realiza um tipo de "fusão" entre uma dword do ponto atual da imagem e um dword 0, foi necessária a realização do dobro de operações, por isso a variável height é multiplicada por 2, o que consequentemente pesará no desempenho da função, como já visto na parte de introdução citada no começo deste documento. 
 
{{{
void CMMXSurface32Intrinsic::GrayScale()
{
    int height = GetVisibleHeight()*2;
    DWORD *pCur  = (DWORD *)GetPixelAddress(0,0);

        CMMX cCur,cRight;
        CMMX cMask;
        CMMX cR,cG,cB;
        CMMX media;

        cCur.UnpackBytesLo( *pCur );
        do {
                int width = m_width;
                do {                    
                        cRight.UnpackBytesLo(pCur[1]);
                        cMask.UnpackBytesLo(0xff);
                        media.Clear();
                        cR = cCur & cMask;
                        cMask = cMask*65536;             //cMask <<= 16;                 
                        cG = cCur & cMask;
                        cMask = cMask*65536;             //cMask <<= 16;                                                                      
                        cB = cCur & cMask;
                        cG = cG/65536;                   //cG >>= 16;                                                                           
                        cB = cB/4294967296;              //cB >>= 32;                                                                           
                        media = (cR + cG + cB)/3;        
                        cCur.Clear();
                        cMask = cMask/4294967296;        //cMask >>= 32;                                                                
                        cCur = cMask;
                        cCur = cCur*65536;               //cCur <<= 16;                                                                         
                        cCur += media;
                        cCur = cCur*65536;               //cCur <<= 16;                                                                         
                        cCur += media;
                        cCur = cCur*65536;               //cCur <<= 16;                                                                         
                        cCur += media;
                        *(ULONGLONG *)pCur = cCur.PackBytes(cCur);
                        cCur = cRight;
                        pCur ++;
                } while (--width > 0);
        } while (--height > 0);
}
}}}

Nota-se que para realizar deslocamentos tanto na máscara quanto no objeto empacotado foram utilizadas multiplicações e divisões. Isto ocorreu devido a uma diferença de resultados entre os operadores >> e << sobrecarregados na classe CMMXUnsigned16Saturated. Com isso o desempenho desta função será drasticamente afetado, apesar de gerar um resultado correto.  

=== SSE(n) ===

TODO: descrever aqui

TODO: descrever o algoritmo e suas implementações

== Sobel (Detecção de bordas) ==

<wiki:comment>
Grupo 5
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

O mecanismo de detecção de borda Sobel é elaborado com a finaliadde de encontrar os pixels onde há uma mudança no nível de intensidade, sendo está mudança uma característica relevante de uma borda em uma imagem. Assim quando esses pixel estão próximos podem ser destacados formando uma borda.
A sua implementação consiste no cálculo do gradiente da imagem. Esse cálculo é feito definindo máscaras que caracterizam a variação de intensidade presente nas bordas de imagens, e em seguida fazer a convolução da imagem pela máscara.

=== _Naive_ ===

{{{

//Máscara do sobel
//X
GXS[0][0] = -1; GXS[0][1] = 0; GXS[0][2] = 1;
GXS[1][0] = -2; GXS[1][1] = 0; GXS[1][2] = 2;
GXS[2][0] = -1; GXS[2][1] = 0; GXS[2][2] = 1;
//Y
GYS[0][0] = -1; GYS[0][1] = -2; GYS[0][2] = -1;
GYS[1][0] = 0; GYS[1][1] = 0; GYS[1][2] = 0;
GYS[2][0] = 1; GYS[2][1] = 2; GYS[2][2] = 1;

void CSurface::Sobel()
{
    COLORREF cCur;

    sumX = 0;
    sumY = 0;
    SUM = 0;

    //Percorre toda imagem
    for (y = 0; y < m_wndHeight; y++) {
        for (x = 0; x <m_wndWidth; x++) {
	    sumX = 0;
	    sumY = 0;

	    //Se for boada, atribui o valor 0(preto)
	    if((y==0) || (y == (m_wndHeight - 1)) || (x==0) || (x == (m_wndWidth - 1)))
	        SUM = 0;
		else{
		    for(I=-1; I<=1; I++){
		        for(J=-1; J<=1; J++){
		            piX = J + x;
			    piY = I + y;

			    //Pega o valor da imagem corrente
			    cCur = PointColor(piX,piY);

			    r = GetRValue(cCur);
			    g = GetGValue(cCur);
			    b = GetBValue(cCur);

			    NC = (r+g+b)/3;

			    sumX = sumX + (NC) * GXS[J+1][I+1];
			    sumY = sumY + (NC) * GYS[J+1][I+1];
			}
		    }

		    SUM = abs(sumX) + abs(sumY);
		}

		if(SUM>255) SUM=255;
		if(SUM<0) SUM=0;
		newPixel = ((unsigned char)(SUM));
			
		PointColorT(x,y,RGB(newPixel,newPixel,newPixel));
	    }
	}

    //Quando terminar, copia o resultado para a imagem corrente
    Copy(t_image);
}
}}}

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Mandelbrot ==

<wiki:comment>
Grupo 6
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

----

= Capture =

----

= GPU (OpenCL) =

<wiki:comment>
Grupo 7
Implementar e descrever a função InvertImage nas versões Normal, MMX e SSE
</wiki:comment>