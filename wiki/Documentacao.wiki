#summary Documentação das funcionalidades implementadas no programa.
#labels Phase-Implementation,Phase-Design

= Introdução =

O objetivo deste projeto é disponibilizar implementações que possam ser usadas para comparar o desempenho das instruções de multimídia nas arquiteturas Intel(r).

O código original do programa pode ser baixado em [http://msdn.microsoft.com/en-us/library/0aws1s9k(v=vs.80).aspx]

----

= Versões 16, 24 e 32 bits =

<wiki:comment>
Grupo 1
Descrever as diferenças de desempenho e em quais implementações se aplicam. (Normal, MMX e SSE)
</wiki:comment>

A análise de desempenho entre as versões de 16, 24 e 32 bits é feita a partir dos códigos-fonte das implementações: Naive, MMX e SSE2.

Primeiramente é importante conhecer a parte teórica referente a cada conjunto de instruções. 

<b>Naive</b>

Trata-se da implementação básica, pois não utiliza um conjunto de instruções específicos para otimização.

<b>MMX</b>

Conjunto de instruções criado pela Intel para aplicações multimídia com a finalidade de aumentar performance. Ele é voltado para a melhora na execução de operações em grandes vetores de dados.
Implementa o modelo de execução SIMD (Single Instruction Multiple Data) pois assim quando se trabalha com arquivos multimídia são utilizados grandes vetores de dados de modo a agilizar a leitura e processamento devido aos registradores de 64 bits.

<b>SSE2</b>

Trata-se do sucessor do MMX e permite aumentar performance em operações de ponto flutuante. Extende as operações do MMX para registradores XMM (64 bits) o que permite ao programador evitar os registradores MM, que não possuem suporte específico para operações de ponto flutuante, fornecendo maior precisão.

=== Estudando o desempenho ===

O gráfico a seguir mostra os resultados de testes feitos usando o código fornecido no repositório para os três conjuntos de instruções citados.

http://chart.apis.google.com/chart?chxl=1:|16+bits|24+bits|32+bits&chxr=0,0,105&chxs=0,676767,11.5,0,lt,676767&chxt=y,x&chbh=14,5,10&chs=300x225&cht=bvg&chco=FF0000,00FF00,0000FF&chds=0,100,0,100,0,105&chd=t:87,84,89|42,77,70|66,105,88&chdl=Naive|MMX|SSE2&chtt=Gr%C3%A1fico+de+Desempenho+%28FPS%29.jpg

|| *Versão* || *Naïve* || *MMX* || *SSE2* ||
|| *16 bits* || 87 || 42 || 66 ||
|| *24 bits* || 84 || 77 || 105 ||
|| *32 bits* || 89 || 70 || 88 ||

Obs1: Valores do eixo y em frames per second (fps) e testados em resolução 320x240.

Obs2: Valores possuem certa variância devido ao fato do computador estar executando outras tarefas.

	Os programas em MMX e SSE2 usam recursos para aumentar a performance das operações e movimentações de informações: utilizam os registradores estendidos de 64 bits para executar várias instruções em um grande vetor de dados em um tempo reduzido, em comparação com os registradores usuais da linguagem. No caso do programa em questão, os registradores são usados para obtenção de vários pixels na tela de uma só vez, e baseado nessas localizações, fazer as operações necessárias em todos estes lugares.

*MMX-16*
	O código MMX para cores com 16 bits de profundidade consiste em:

1.	Passar o endereço do pixel da posição corrente para uma variável pCur, no formato ULONGLONG(64bits).

2.	Por manipulação deste ponteiro, obter as posições dos pixels ao redor (cUp, cDown, cLeft, cRight, cCur) e compará-los a uma máscara previamente inicializada para editar os bits das posições relevantes à cor.


Após isto, as cores dos pixels ao redor são usadas na modificação desejada (no caso, estamos analisando o efeito Blur). A distribuição das cores é feita entre os pixels, e a próxima posição desejada é calculada. A operação é repetida.

*MMX-24*
	O código MMX para cores com 24 bits de profundidade consiste em:

1.	Passar o endereço da posição corrente para uma variável pCur, no formato DWORD. 

2.	Cria-se uma variável de 64 bits cFader, que será usada nas operações para a modificação dos valores dos pixels. Isto é feito a partir de uma operação chamada UnpackBytesLo de forma simplificada ele pega a dword que pCur aponta e faz um tipo de concatenação com uma dword cheia de zeros da seguinte forma: suponha que pCur aponta pra dword ff0a0b0c. Neste caso, 0a0b0c representa o RGB do pixel e ff sua transparência. Quando se chama cCur.UnpackBytesLo ( *pCur ), ele empacota na variável cCur uma QWORD 00ff000a000b000c, ou seja, ele faz uma "mescla" byte a byte do vetor passado como referência com um vetor de zeros. Então, as operações feitas neste registrador são feitas duas vezes mais (como se fossem feitas em um bit válido e um bit que sempre está em zero). Isto rende uma perda de performance.

3.	Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes são "desempacotados" e usados nas operações de modificação de cores. Calcula-se o próximo pixel e repete-se o passo 3.

*MMX-32*
	O código MMX para cores com 32 bits de profundidade consiste em:
1.	Passar o endereço da posição corrente para uma variável pCur, no formato ULONGLONG. 
2.	Após todas as declarações, entra-se no loop da operação: A partir do ponteiro inicial, os pixels adjacentes(contando com os pixels da diagonal direita superior, diagonal direita inferior e o segundo pixel da direita) são "desempacotados" e usados nas operações de modificação de cores. 
3.	Depois das modificações das cores, os pixels são reempacotados em uma variável de 64 bits. Repetem-se os passos 2 e 3.

_Observações sobre MMX:_
	Todas as operações em MMX envolvem o uso de instruções de empacotamento de bytes. Estas instruções tem alguns pontos onde a performance do sistema é afetada por operações desnecessárias nos pixels. Por exemplo, o PUNPCKLBW, instrução MMX para o desempacotamento de uma DWORD, gera bits zerados que não contribuem para o programa, e que entram em loops e operações supérfluas.
	Podemos ver pela performance dos códigos em MMX que estes não são eficientes neste programa, sendo mais lentos que a implementação Naïve e a SSE2.


SSE2-16
<TODO: >
SSE2-24
<TODO: >
SSE2-32
<TODO: >

Análise por LOC (assembly)
	MMX-16: aprox. 538 LOC

	MMX-24: aprox. 204 LOC

	MMX-32: aprox. 283 LOC

	SSE2-16: aprox. 533 LOC

	SSE2-24: aprox. 301 LOC

	SSE2-32: aprox. 311 LOC

<TODO: >



----

= Implementações =

<wiki:comment>
Grupo 2
Descrever Blur, Blit e Swarm nas três versões (Normal, MMX e SSE).
</wiki:comment>

== Blur/Smooth (Borrar) ==

Este efeito é obtido por meio da média do pixel com seus vizinhos, porém o pixel central tem peso maior.

=== _Naive_ ===

Nesta implementação o valor de cada pixel é multiplicado por 4 (`GetRValue(cCur) << 2`), somado aos 4 vizinhos e dividido por 8.

{{{
void CSurface::BlurBits()
{
    COLORREF cLeft = 0, cCur = PointColor(0,0), cRight, cUp, cDown;
    BYTE r, g, b;
    for (int i = 0; i < m_wndHeight; i++) {
        cLeft = 0;
        for (int j = 0; j < m_wndWidth; j++) {
            cRight = PointColor(j+1, i);
            cUp = PointColor(j, i-1);
            cDown = PointColor(j, i+1);
            r = (BYTE)(((int)(GetRValue(cCur) << 2) + GetRValue(cLeft) + GetRValue(cRight) + GetRValue(cUp) + GetRValue(cDown)) >> 3);
            g = (BYTE)(((int)(GetGValue(cCur) << 2) + GetGValue(cLeft) + GetGValue(cRight) + GetGValue(cUp) + GetGValue(cDown)) >> 3);
            b = (BYTE)(((int)(GetBValue(cCur) << 2) + GetBValue(cLeft) + GetBValue(cRight) + GetBValue(cUp) + GetBValue(cDown)) >> 3);
            PointColor(j, i, RGB(b,g,r)); // RGBs are physically inverted
            cLeft = cCur;
            cCur = cRight;
        }
    }
}
}}}

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Blit ==

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Swarm ==

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Fade In/Out (Transição) ==

<wiki:comment>
Grupo 3
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Esta funcionalidade faz a transição de uma imagem a outra e está implementada apenas com instruções de ponto flutuante (_Naive_).

=== _Naive_ ===

Nesta implementação o valor de `alpha` varia entre 0.0 e 1.0 gradualmente fazendo com que a imagem de origem `cO` se transforme na imagem de destino `cD`.

{{{
            r = (BYTE)((GetRValue(cO)*alpha+GetRValue(cD)*(1.0-alpha)));
            g = (BYTE)((GetGValue(cO)*alpha+GetGValue(cD)*(1.0-alpha)));
            b = (BYTE)((GetBValue(cO)*alpha+GetBValue(cD)*(1.0-alpha)));
}}}

=== MMX ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CMMXUnsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

=== SSE(n) ===

A implementação pode usar _inline assembly_ ou declarar objetos do tipo `CSSE2Unsigned16Saturated` ou outros para invocar métodos como `UnpackBytesLo`, `PackBytes` e `Clear`.

TODO: implementar e descrever aqui

== Grayscale (Tons de cinza) ==

<wiki:comment>
Grupo 4
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

Este filtro transforma a imagem atual em uma imagem com tons de cinza.

=== _Naive_ ===

Para esta implementação os valores R, G, B são atualizados com uma média simples entre estes valores.

{{{
void CSurface::GrayScale()
{
	COLORREF cCur;
	BYTE r, g, b;

	for (int i = 0; i < m_wndHeight; i++) {
		for (int j = 0; j < m_wndWidth; j++) {
			cCur = PointColor(j,i);
			r = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			g = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);
			b = (BYTE)((GetRValue(cCur)+GetGValue(cCur)+GetBValue(cCur))/3);			
			PointColor(j,i,RGB(b,g,r));
		}
	}
}
}}}


=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

TODO: descrever o algoritmo e suas implementações

== Sobel (Detecção de bordas) ==

<wiki:comment>
Grupo 5
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

TODO: descrever o algoritmo e suas implementações

=== _Naive_ ===

TODO: descrever aqui

=== MMX ===

TODO: descrever aqui

=== SSE(n) ===

TODO: descrever aqui

== Mandelbrot ==

<wiki:comment>
Grupo 6
Implementar e descrever as nas versões Normal, MMX e SSE.
</wiki:comment>

----

= Capture =

----

= GPU (OpenCL) =

<wiki:comment>
Grupo 7
Implementar e descrever a função InvertImage nas versões Normal, MMX e SSE
</wiki:comment>