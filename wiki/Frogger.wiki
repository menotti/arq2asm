#Descricao do projeto Frogger.

[http://sphotos-a.ak.fbcdn.net/hphotos-ak-ash3/528879_331991300240669_283131540_n.jpg]

_Descrição: tela de introdução do jogo Frogger. Imagem carregada dinamicamente do arquivo Frogger.txt_

= Introdução =

Documentação do jogo Frogger, desenvolvido pela disciplina de Laboratório de Arquitetura e Organização de Computadores II.

O objetivo do jogo consiste em, controlando um sapo, conseguir caminhar até o gramado do outro lado do cenário. O cenário oferece dois tipos de obstáculos: a rodovia e o rio. Para atravessar a rodovia, basta impedir que o sapo colida com qualquer um dos veículos. Para atravessar o rio, por outro lado, é necessário caminha pelos troncos flutuantes, sem deixar o sapo cair na água.

 * *Data de criação*: 18/12/2012
 * *Última modificação*: 24/01/2013

-------------
= Grupo de alunos =

 * *Antonio Pedro Avanzi Nunes* - 407852
 * *Lucas Oliveira David* - 407917
 * *Pedro Padoveze Barbosa* - 407895

-------------
= Detalhes da implementação (versão 1.0) =

O jogo foi dividido em duas partes. Uma lógica e uma gráfica. Ambas as partes funcionam de forma independente, a fim de garantir uma melhor integração entre diferentes trabalhos dos integrantes do grupo no código em si.

Para a implementação da parte lógica, foi utilizado uma estrutura de dados do tipo tabela, de tamanho 15x15, representada a partir do vetor FROG_Campo. O vetor armazena valores inteiros de 16 bits.
Cada inteiro representa um determinado objeto, e a parte gráfica do jogo será responsável por obter tais inteiros e associá-los a diferentes caracteres:

 * 0: chão ou tronco.
 * 1 - 6: diferentes veículos que estão na rodovia.
 * 7: água.
 * 9: o sapo.

_Importante: todos os elementos do campo possuem o valor menor que o sapo! Isso é essencial para que a lógica funcione corretamente. Entretanto, tais valores podem variar. Em outras palavras, é possível criar novos objetos._

A matriz do jogo é obtida de forma dinâmica de um arquivo texto "campo.txt".

Quando as teclas são pressionadas, verificamos se o sapo está na fronteira da matriz através das variáveis *FROG_sapoX* e *FROG_sapoY*. Se sim, não fazemos nada. Caso contrário, subtraímos o valor do sapo na posição atual e adicionamos seu valor à nova posição, além de atualizar os indexadores FROG_sapoX e FROG_sapoY.

A movimentação dos veículos acontece de forma similar: vetores armazenam quais linhas na matriz possuem veículos, seus sentidos e suas velocidades. A cada interação, o carro é movimentado para a esquerda ou direita através da subtração e da soma.

No caso do rio, quem se move de fato é a água. Porém, tal efeito faz parece que quem está se movendo são os troncos. Nota-se que se o sapo estiver sobre um tronco qualquer, ele "se move" juntamente com esse, um fato que não ocorre durante a rotação do transito.

A cada interação, de movimentação do sapo, dos veículos ou da água, um procedimento (FROG_VerificarColisao) é chamado. Esse procedimento varre toda a tabela e verificamos se existe algum elemento que seja maior que o valor do sapo. Se sim, sabemos que o sapo está ocupando a mesma posição que um carro, e o jogo é finalizado, exibindo a tela de derrota.

A cada interação também é verificado se o valor do sapo é encontrado na primeira linha da matriz. Se sim, significa que o sapo atingiu a última faixa da rodovia. O jogo é finalizado e a tela de vitória, exibida.

-------------
= Descrição das informações armazenadas = 

== Constantes ==

 * *FROG_SAPO_A*: define numérico referente ao sapo A!
 * *FROG_SAPO_B*: define numérico referente ao sapo B!
 * *FROG_CAMPO_TAM*: tamanho de entrada do campo extraído de um arquivo.
 * *FROG_INTRO_TAM*: tamanho da introdução extraída do arquivo.
 * *FROG_LINHAS*: n. de linhas da matriz que representa o campo.
 * *FROG_COLUNAS*: n. de colunas da matriz que representa o campo.
 * *FROG_CAMPO_INI_X*: define a coordenada X onde o mapa começará a ser desenhado.
 * *FROG_CAMPO_INI_Y*: define a coordenada Y onde o mapa começará a ser desenhado.

== Variáveis ==

 * *FROG_respiracao*: variável auxiliar para a criação do efeito de respiração do sapo. Também utilizada para as animações dos obstáculos 7 e 8.
 * *FROG_ganharamJogo*: mostra que os sapos ganharam o jogo.
 * *FROG_Movimentos*: contabiliza os movimentos dos sapos.
 * *FROG_Movimento_Total*: contabiliza os movimentos dos sapos das fases que já passaram.

=== Variáveis de Movimentos ===

 * *FROG_TransitoLinha*: armazena quais das FROG_LINHAS da matriz contem elementos nocivos ao sapo.
 * *FROG_TransitoVeloc*: armazena a velocidade com que os elementos contidos nas FROG_LINHAS referenciadas por FROG_TransitoLinha andam no 
cenário.
 * *FROG_VelocAtual*: serve como contador para ajustar o delay de velocidade sem perder os valores de FROG_TransitoVeloc
 * *FROG_TransitoSentido*: armazena o sentido dos elementos contidos em FROG_TransitoLinha.

=== Variáveis Relativas a Arquivo ===

 * *FROG_Intro*: matriz que armazena imagem da tela de introdução.
 * *FROG_Campo*: o campo por onde toda a lógica do jogo está estruturada.
 * *FROG_Campo_Temp*: matriz temporária no processo de leitura do arquivo.
 * *FROG_fCampo*: arquivo de inicialização do campo. Default: (src/Frogger/campo.txt)
 * *FROG_fIntro*: arquivo do desenho inicial do sapo. Default: (src/Frogger/frogger.txt)
 * *FROG_fHandle*: manipulador geral dos arquivos.

=== Variáveis do Sapo A ===

 * * FROG_sapoA_X*: armazena a posição horizontal do sapo A no campo.
 * * FROG_sapoA_Y*: armazena a posição vertical do sapo A no campo.
 * * FROG_ApassouFase*: verifica se o sapo A passou de fase.
 * * FROG_AperdeuJogo*: verifica se o sapo A perdeu.
 * * FROG_A_Vidas*: contabiliza o número de vidas do sapo A.

=== Variáveis do Sapo B ===

 * * FROG_sapoB_X*: armazena a posição horizontal do sapo B no campo.
 * * FROG_sapoB_Y*: armazena a posição vertical do sapo B no campo.
 * * FROG_BpassouFase*: verifica se o sapo B passou de fase.
 * * FROG_BperdeuJogo*: verifica se o sapo B perdeu.
 * * FROG_B_Vidas*: contabiliza o número de vidas do sapo B.

-------------

= Procedimentos =

 * *FROG_Clock*: procedimento principal, executa um loop ate que o jogador ganhe, perca ou saia do jogo.

== Procedimentos de Movimento ==

 * *FROG_VerificarColisao*: verifica se o sapo colidiu com um carro. Para isso, percorre a matriz inteira, verificando se existe algum elemento para qual o valor ee maior que o valor do sapo (considera-se que nenhum outro elemento tem valor maior que o sapo). Se sim, houve colisão e a variável FROG_perdeuJogo = 1. Caso contrario, nada acontece.
 * *FROG_VerificarVitoria*: verifica se a posição vertical do sapo é 1. Se sim, ele esta na primeira linha, o que mostra que este atravessou todo o campo. A variável FROG_ganhouJogo recebe 1. Caso contrario, nada acontece.
 * *FROG_ControleMovimento*: lê uma tecla pressionada pelo jogador e, caso essa seja uma seta direcional, chama um dos seguintes procedimentos, a fim de movimentar o sapo pelo campo.

 * * FROG_MovimentaEsq *: movimenta para a esquerda.
 * * FROG_MovimentaDir *: movimenta para a direita.
 * * FROG_MovimentaCima *: movimenta para cima.
 * * FROG_MovimentaBaixo *: movimenta para baixo.

 * *FROG_AtualizarTransito*: interpreta os vetores responsáveis por definir quais linhas, em qual sentido e com que velocidade devem se movimentar e invoca o procedimento pra realizar tal operação.
 * *FROG_RotacionarTransito*: dados a linha (dx) e o sentido (ax), rotaciona os elementos da linha.
 * *FROG_RotacionarAgua*: executa a mesma operação que o procedimento acima, mas para os elementos superiores da matriz. Esse procedimento também rotaciona o sapo (visualmente, ele estaria sobre uma plataforma de madeira).

== Procedimentos de Jogo/Campo ==

 * *FROG_InitJogo*: chama o procedimento acima, estabelece o número de vidas, e chama o procedimento abaixo.
 * *FROG_LerCampo*: lê o arquivo de campo e grava ele em um vetor.
 * *FROG_DefinirCampo*: define o campo, a partir do vetor que armazena as informações do arquivo.
 * *FROG_NovoCampo*: aumenta a variável que guarda o nome do arquivo (para a próxima fase) e chama FROG_DefinirCampo.
 * *FROG_NovoJogo*: restaura os valores inicias das variáveis e do campo.

=== Procedimentos de Desenho ===

 * *FROG_DesenharCampo*: atualiza o campo no console.
 * *FROG_DesenharCaracteres*: chamado pelo procedimento acima, esse tem como objetivo interpretar os elementos na matriz e desenhá-los no console de um jeito melhor.

== Procedimentos de Exibição ==

 * *FROG_ExibirIntro*: exibe janela de introdução.
 * *FROG_ExibirVitoria*: exibe janela de vitória.
 * *FROG_ExibirDerrota*: exibe janela de derrota.
 * *FROG_EntreFases*: exibe uma tela preta com mensagem que mostra qual o número e nome do próximo level. Espera Enter para continuar.
 * *FROG_PressEnter*: exibe a mensagem de "pressione enter" abaixo do campo e espera o Enter ser inserido.
 * *FROG_ExibirHUD*: mostra informações, como número de vidas, número de passos, level da fase, nome da fase, etc...

-------------
= Correção de bugs (versão 1.1) =

Os _bugs_ presentes na versão 1.0, que implicavam na duplicação do sapo quando este se movimentava rapidamente ou que impediam que os carros se movimentassem no limite da matriz foi corrigido, estando estes correlacionados. Outro bug que também foi corrigido nessa versão: o clock exigia uma grande quantidade de tempo para processar as informações, quando o sapo se encontrava na primeira linha (mais à cima). A partir daqui, as versões 1.2a e 1.2b puderam finalmente se iniciar.

= Modo cooperativo (versão 1.2a) =

*Ideia inicial: co-op!*
A fim de cumprir com as novas regras do jogo - a vitória agora ocorre quando os dois sapos atravessam o campo, enquanto a derrota ocorre quando um dos sapos perde suas três vidas - a implementação do modo cooperativo ocorreu através da duplicação de várias variáveis que eram relaciondas ao sapo A. As novas variáveis então fariam referência ao sapo B. Os procedimentos RotacionaAgua, RotacionaTransito, VerificaDerrota, VerificaVitoria, ControleMovimento, Init e Clock também foram modificados para que o jogo aceitasse os dois jogadores.

*Diferenciando colisões com os diferentes sapos...*
O sapo B assume o valor do sapo A multiplicado por 2. Temos, por uma definição acima que todos os elementos possuem um valor inferior que o sapo A. Logo, para sabermos qual sapo colidiu com algum objeto, verificamos se
 * Existe um valor maior que o sapo A e menor que o sapo B: o sapo A colidiu!
 * Existe um valor maior que o sapo B: o sapo B colidiu!

_Nota: na teoria, seria possível modificar facilmente o algoritmo a fim de incluir mais sapos no jogo._

*Como jogar com um único sapo?*
No início do jogo, é verificado se ele esta no modo cooperativo. Se não, o sapo B não é posicionado na matriz e sua variável FROG_BganhouJogo assume o valor verdadeiro. Desta forma, assim que o sapo A chegar ao outro lado, ele vencerá sozinho o jogo.

*Como o sapo B pode jogar?*
No decorrer do jogo, se a tecla F2 for pressionada, o sapo B será inserido no campo de forma "online" (e a posição do sapo A será restaurada para a inicial).

*Contando seus passos...*
Um contador de passos é utilizado. A cada movimentação de um dos sapos, este é incrementado. Tal elemento tem como objetivo incentivar os jogadores a realizarem um número mínimo de passos (14, considerando o tamanho padrão da matriz).

*Novo jeito de exibir informações:*
Com um crescimento na quantidade de informação que necessitava ser mostrada, um procedimento chamado FROG_ExibirHUD foi criado. Dentro deste procedimento, o cursor é deslocado para uma posição pré-definida e
exibe informações relativas às vidas restantes dos sapos (ou a tecla necessária para a entrada de um novo sapo), além do número de passos realizados.

-------------
= Progressão de multiplas fases e leitura dinâmica de texturas (versão 1.2b) =

Nesta versão, foi implementado um leitor que pudesse carregar dinamicamente de arquivos nomeados de forma sequencial "campo00.txt" e, a partir desses, carregar fases no jogo.

Quando o(os) sapo(os) vence(em) uma fase, o leitor buscará a próxima fase na pasta src/Frogger/. Caso exista, essa fase será carregada. Caso contrário, o jogo acaba e o jogador finalmente venceu o jogo.

As propriedades das fases estão mais livres. Agora, é possível definir não só a ordem dos objetos pelos arquivos, mas também suas velocidades e suas texturas.

[http://sphotos-h.ak.fbcdn.net/hphotos-ak-prn1/69597_332316380208161_1295791066_n.jpg]

No exemplo acima, é possível ver a estrutura de cada arquivo. É *ESTRITAMENTE* importante que os primeiros 582 caracteres estejam estruturados dessa forma, incluindo a divisão em linhas. (totalizando 648 bytes) Qualquer caractere depois disso será irrelevante.

A partir da procedimento FROG_LerMapa, o jogo carrega em um vetor de 648 bytes o arquivo, e acessa esse vetor em uma determinada posição para informação.

 * "Título##############" (os 20 primeiros bytes são reservados para o título do mapa, que, se menor que 20, deve ser preenchido com # no final até obter o tamanho de 20 bytes)

 * "S S 000000000000000 XXX CC XXX" representa cada uma das 15 linhas do mapa.

No lugar do primeiro S, coloca-se a direção (par: direita, ímpar: esquerda; caso seja 2 ou 3, o sapo se movimentará automaticamente na linha, como em exemplos de água). Nota-se que caso o sentido seja S, a linha não terá movimento.

No lugar do segundo S, coloca-se a velocidade. (1 é a maior velocidade possível, 4 já é uma velocidade bem lerda)

Os quinze 0s representam o quê de fato terá naquela linha, no campo. (0 representam chão. 1 a 8 representam obstáculos)

Os primeiros XXX representam a parte de cima do desenho do chão, daquela linha.

Os CC representam a cor do desenho do chão (para ambas as partes de cima e de baixo). Ver abaixo sobre as cores.

Os segundos XXX representam a parte de baixo do desenho do chão, daquela linha.

 * XXX CC
 * XXX CC

Em ordem, para cada um dos seis exemplos acima, temos os gráficos dos obstáculos de 1 a 6.

Os primeiros XXX representam a parte de cima do obstáculo.

Os primeiros CC representam a cor da parte de cima do obstáculo.

Os segundos XXX representam a parte de baixo do obstáculo.

Os segundos CC representam a cor da parte de baixo do obstáculo.

 * XXX CC XXX
 * XXX CC XXX

Representando, em ordem, os obstáculos 7 e 8. Em relação aos primeiros XXX e CC de cada linha, eles são iguais ao descrito acima. Porém, esses obstáculos possem um segundo gráfico (respiração), que será exibido no lugar do original em metade do tempo.

Os XXX após a parte de cima representam a segunda imagem da parte de cima.

Os XXX após a parte de baixo representam a segunda imagem da parte de baixo.

== Cores ==

O primeiro C representa a cor de fundo a ser exibida, e o segundo C representa a cor dos caracteres a serem exibidos.

As cores são:

0 - Preto

1 - Azul

2 - Verde

3 - Cyan

4 - Red

5 - Vermelho

6 - Rosa

7 - Marrom

8 - Cinza Claro

9 - Cinza

A - Azul Claro

B - Verde Claro

C - Cyan Claro

D - Rosa Claro

E - Amarelo

F - Branco

-------------
= Junção das versões 1.2a e 1.2b (versão 1.3) =

Esta é a versão final do jogo. A junção das duas versões anteriores (1.2a e 1.2b) foi realizada, o que se mostrou uma tarefa extremamente difícil. Pequenos ajustes também foram realizados, como a necessidade de limpar as variáveis que definiam os campos (o jogo não assumia os valores corretos quando o jogo reiniciava).
O resultado pode ser visto na imagem abaixo:
[http://i37.photobucket.com/albums/e81/0810119020/B_zpsdb2b66f1.png]

-------------
= O Jogo =

O jogo é atualmente composto por dez fases.

1. Barão Geraldo City

[http://sphotos-d.ak.fbcdn.net/hphotos-ak-ash4/314873_331996443573488_1654685255_n.jpg]

2. São Paulo City

[http://sphotos-b.ak.fbcdn.net/hphotos-ak-ash4/484732_331996450240154_1100967264_n.jpg]

3. Nova York City

[http://sphotos-h.ak.fbcdn.net/hphotos-ak-prn1/69644_331996453573487_1729904192_n.jpg]

4. Vulcano

[http://sphotos-e.ak.fbcdn.net/hphotos-ak-ash4/309757_331996483573484_459190532_n.jpg]

5. Digital Chaos

[http://sphotos-c.ak.fbcdn.net/hphotos-ak-ash4/408498_331996490240150_743562494_n.jpg]

6. Amazonas Rainforest

[http://sphotos-a.ak.fbcdn.net/hphotos-ak-prn1/46709_331996500240149_1736752528_n.jpg]

7. Texas Stampede

[http://sphotos-g.ak.fbcdn.net/hphotos-ak-ash4/385369_331996520240147_1349147487_n.jpg]

8. The Asteroid Field

[http://sphotos-e.ak.fbcdn.net/hphotos-ak-ash4/408534_331998680239931_1383827925_n.jpg]

9. The Helltrix

[http://sphotos-b.ak.fbcdn.net/hphotos-ak-ash3/533855_331996536906812_1417044941_n.jpg]

10. The Final Boss

[http://sphotos-e.ak.fbcdn.net/hphotos-ak-ash3/549931_331996550240144_1491065989_n.jpg]

--------------
#FIM DO DOCUMENTO